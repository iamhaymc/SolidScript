!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).SOLIDS={})}(this,function(e){"use strict";var r,t,n,o,i,s,u,a,c,l,f,h,g,d,m,q,p,y,v,w,b,x,E,A,$,P,M,T,C,S,F,V,R,G,k,N,O,z,I,B,D,j,L,_,Z,X,U,H,Y,W,J,Q,K,ee,re,te,ne,oe,ie,se,ue,ae,ce,le,fe,he,ge,de,me,qe,pe,ye,ve,we,be,xe,Ee,Ae,$e,Pe,Me,Te,Ce,Se,Fe,Ve,Re,Ge,ke,Ne,Oe,ze,Ie,Be,De,je,Le,_e,Ze,Xe,Ue,He,Ye,We,Je,Qe,Ke,er,rr,tr,nr,or,ir,sr,ur,ar,cr,lr,fr,hr,gr,dr,mr,qr,pr,yr,vr,wr,br,xr,Er,Ar,$r,Pr,Mr,Tr,Cr,Sr,Fr,Vr,Rr,Gr,kr,Nr,Or,zr,Ir,Br,Dr,jr,Lr,_r,Zr,Xr,Ur,Hr,Yr,Wr,Jr,Qr,Kr,et,rt,tt,nt,ot,it,st,ut,at,ct,lt,ft,ht,gt,dt,mt,qt,pt,yt,vt,wt,bt,xt,Et,At,$t,Pt,Mt,Tt,Ct,St,Ft,Vt,Rt,Gt,kt,Nt,Ot,zt,It,Bt,Dt,jt,Lt,_t,Zt,Xt,Ut,Ht,Yt,Wt,Jt,Qt,Kt,en,rn,tn,nn,on,sn,un,an,cn,ln,fn,hn,gn,dn,mn,qn,pn,yn,vn,wn,bn,xn,En,An,$n,Pn,Mn,Tn,Cn,Sn,Fn,Vn,Rn,Gn,kn,Nn,On,zn,In,Bn,Dn,jn,Ln,_n,Zn,Xn,Un,Hn,Yn,Wn,Jn,Qn,Kn,eo,ro,to,no,oo,io,so,uo,ao,co,lo,fo,ho,go,mo,qo,po,yo,vo,wo,bo,xo,Eo,Ao,$o,Po,Mo,To,Co,So,Fo,Vo,Ro,Go,ko,No,Oo,zo,Io,Bo,Do,jo,Lo,_o,Zo,Xo,Uo,Ho,Yo,Wo,Jo,Qo,Ko,ei,ri,ti,ni,oi,ii,si,ui,ai,ci,li,fi,hi,gi,di,mi,qi,pi,yi,vi,wi,bi,xi,Ei,Ai,$i,Pi,Mi,Ti,Ci,Si,Fi,Vi,Ri,Gi,ki,Ni,Oi,zi,Ii,Bi,Di,ji,Li,_i,Zi,Xi,Ui,Hi,Yi,Wi,Ji,Qi,Ki,es,rs,ts,ns,os,is,ss,us,as,cs,ls,fs,hs,gs,ds,ms,qs,ps,ys,vs,ws,bs,xs,Es,As,$s,Ps,Ms,Ts,Cs,Ss,Fs,Vs,Rs,Gs,ks,Ns,Os,zs,Is,Bs,Ds,js,Ls,_s,Zs,Xs,Us,Hs,Ys,Ws,Js,Qs,Ks,eu,ru,tu,nu,ou,iu,su,uu,au,cu,lu,fu,hu,gu,du,mu,qu,pu,yu,vu,wu,bu,xu,Eu,Au,$u,Pu,Mu,Tu,Cu,Su,Fu,Vu,Ru,Gu,ku,Nu,Ou,zu,Iu,Bu,Du,ju,Lu,_u,Zu,Xu,Uu,Hu,Yu,Wu,Ju,Qu,Ku,ea,ra,ta,na,oa,ia,sa,ua,aa,ca,la,fa,ha,ga,da,ma,qa,pa,ya,va,wa,ba,xa,Ea,Aa,$a,Pa,Ma,Ta,Ca,Sa,Fa,Va,Ra,Ga,ka,Na,Oa,za,Ia,Ba,Da,ja,La,_a,Za,Xa,Ua,Ha,Ya,Wa,Ja,Qa,Ka,ec,rc,tc,nc,oc,ic,sc,uc,ac,cc,lc,fc,hc,gc,dc,mc,qc,pc,yc,vc,wc,bc,xc,Ec,Ac,$c,Pc,Mc,Tc,Cc,Sc,Fc,Vc,Rc,Gc,kc,Nc,Oc,zc,Ic,Bc,Dc,jc,Lc,_c,Zc,Xc,Uc,Hc,Yc,Wc,Jc,Qc,Kc,el,rl,tl,nl,ol,il,sl,ul,al,cl,ll,fl,hl,gl,dl,ml,ql,pl,yl,vl,wl,bl,xl,El,Al,$l,Pl,Ml,Tl,Cl,Sl,Fl,Vl,Rl,Gl,kl,Nl,Ol,zl,Il,Bl,Dl,jl,Ll,_l,Zl,Xl,Ul,Hl,Yl,Wl,Jl,Ql,Kl,ef,rf,tf,nf,of,sf,uf,af,cf,lf,ff,hf,gf,df,mf,qf,pf,yf,vf,wf,bf,xf,Ef,Af,$f,Pf,Mf,Tf,Cf,Sf,Ff,Vf,Rf,Gf,kf,Nf,Of,zf,If,Bf,Df,jf,Lf,_f,Zf,Xf,Uf,Hf,Yf,Wf,Jf,Qf,Kf,eh,rh,th,nh,oh,ih,sh,uh,ah,ch,lh,fh,hh,gh,dh,mh,qh,ph,yh,vh,wh,bh,xh,Eh,Ah,$h,Ph,Mh,Th,Ch,Sh,Fh,Vh,Rh,Gh,kh,Nh,Oh,zh,Ih,Bh,Dh,jh,Lh,_h,Zh,Xh,Uh,Hh,Yh,Wh,Jh,Qh,Kh,eg,rg,tg,ng,og,ig,sg,ug,ag,cg,lg,fg,hg,gg,dg,mg,qg,pg,yg,vg,wg,bg,xg,Eg,Ag,$g,Pg,Mg,Tg,Cg,Sg,Fg,Vg,Rg,Gg,kg,Ng,Og,zg,Ig,Bg,Dg,jg,Lg,_g,Zg,Xg,Ug,Hg,Yg,Wg,Jg,Qg,Kg,ed,rd;function requireFlatten$1(){if(t)return r;t=1;const flatten=e=>e.reduce((e,r)=>Array.isArray(r)?e.concat(flatten(r)):e.concat(r),[]);return r=flatten}function requireClone$a(){if(o)return n;o=1;return n=e=>Object.assign({},e)}function requireAdd$2(){if(s)return i;s=1;return i=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e[2]=r[2]+t[2],e[3]=r[3]+t[3],e[4]=r[4]+t[4],e[5]=r[5]+t[5],e[6]=r[6]+t[6],e[7]=r[7]+t[7],e[8]=r[8]+t[8],e[9]=r[9]+t[9],e[10]=r[10]+t[10],e[11]=r[11]+t[11],e[12]=r[12]+t[12],e[13]=r[13]+t[13],e[14]=r[14]+t[14],e[15]=r[15]+t[15],e)}function requireCreate$c(){if(a)return u;a=1;return u=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function requireClone$9(){if(l)return c;l=1;const e=requireCreate$c();return c=r=>{const t=e();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],t}}function requireCopy$5(){if(h)return f;h=1;return f=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e)}function requireInvert$2(){if(d)return g;d=1;return g=(e,r)=>{const t=r[0],n=r[1],o=r[2],i=r[3],s=r[4],u=r[5],a=r[6],c=r[7],l=r[8],f=r[9],h=r[10],g=r[11],d=r[12],m=r[13],q=r[14],p=r[15],y=t*u-n*s,v=t*a-o*s,w=t*c-i*s,b=n*a-o*u,x=n*c-i*u,E=o*c-i*a,A=l*m-f*d,$=l*q-h*d,P=l*p-g*d,M=f*q-h*m,T=f*p-g*m,C=h*p-g*q;let S=y*C-v*T+w*M+b*P-x*$+E*A;return S?(S=1/S,e[0]=(u*C-a*T+c*M)*S,e[1]=(o*T-n*C-i*M)*S,e[2]=(m*E-q*x+p*b)*S,e[3]=(h*x-f*E-g*b)*S,e[4]=(a*P-s*C-c*$)*S,e[5]=(t*C-o*P+i*$)*S,e[6]=(q*w-d*E-p*v)*S,e[7]=(l*E-h*w+g*v)*S,e[8]=(s*T-u*P+c*A)*S,e[9]=(n*P-t*T-i*A)*S,e[10]=(d*x-m*w+p*y)*S,e[11]=(f*w-l*x-g*y)*S,e[12]=(u*$-s*M-a*A)*S,e[13]=(t*M-n*$+o*A)*S,e[14]=(m*v-d*b-q*y)*S,e[15]=(l*b-f*v+h*y)*S,e):null}}function requireEquals$7(){if(q)return m;q=1;return m=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]&&e[3]===r[3]&&e[4]===r[4]&&e[5]===r[5]&&e[6]===r[6]&&e[7]===r[7]&&e[8]===r[8]&&e[9]===r[9]&&e[10]===r[10]&&e[11]===r[11]&&e[12]===r[12]&&e[13]===r[13]&&e[14]===r[14]&&e[15]===r[15]}function requireConstants(){if(y)return p;y=1;const e=2*Math.PI;return p={EPS:1e-5,NEPS:1e-13,TAU:e,spatialResolution:1e5}}function requireTrigonometry(){if(w)return v;w=1;const{NEPS:e}=requireConstants(),rezero=r=>Math.abs(r)<e?0:r;return v={sin:e=>rezero(Math.sin(e)),cos:e=>rezero(Math.cos(e))}}function requireIdentity(){if(x)return b;x=1;return b=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function requireFromRotation(){if(A)return E;A=1;const{EPS:e}=requireConstants(),{sin:r,cos:t}=requireTrigonometry(),n=requireIdentity();return E=(o,i,s)=>{let[u,a,c]=s;const l=u*u+a*a+c*c;if(Math.abs(l)<e)return n(o);const f=1/Math.sqrt(l);u*=f,a*=f,c*=f;const h=r(i),g=t(i),d=1-g;return o[0]=u*u*d+g,o[1]=a*u*d+c*h,o[2]=c*u*d-a*h,o[3]=0,o[4]=u*a*d-c*h,o[5]=a*a*d+g,o[6]=c*a*d+u*h,o[7]=0,o[8]=u*c*d+a*h,o[9]=a*c*d-u*h,o[10]=c*c*d+g,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,o}}function requireFromScaling(){if(P)return $;P=1;return $=(e,r)=>(e[0]=r[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=r[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function requireFromTaitBryanRotation(){if(T)return M;T=1;const{sin:e,cos:r}=requireTrigonometry();return M=(t,n,o,i)=>{const s=e(n),u=r(n),a=e(o),c=r(o),l=e(i),f=r(i);return t[0]=c*u,t[1]=c*s,t[2]=-a,t[3]=0,t[4]=l*a*u-f*s,t[5]=f*u+l*a*s,t[6]=l*c,t[7]=0,t[8]=l*s+f*a*u,t[9]=f*a*s-l*u,t[10]=f*c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}}function requireFromTranslation(){if(S)return C;S=1;return C=(e,r)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e)}function requireFromValues$4(){if(V)return F;V=1;const e=requireCreate$c();return F=(r,t,n,o,i,s,u,a,c,l,f,h,g,d,m,q)=>{const p=e();return p[0]=r,p[1]=t,p[2]=n,p[3]=o,p[4]=i,p[5]=s,p[6]=u,p[7]=a,p[8]=c,p[9]=l,p[10]=f,p[11]=h,p[12]=g,p[13]=d,p[14]=m,p[15]=q,p}}function requireAbs$1(){if(G)return R;G=1;return R=(e,r)=>(e[0]=Math.abs(r[0]),e[1]=Math.abs(r[1]),e[2]=Math.abs(r[2]),e)}function requireAdd$1(){if(N)return k;N=1;return k=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e[2]=r[2]+t[2],e)}function requireDot$2(){if(z)return O;z=1;return O=(e,r)=>e[0]*r[0]+e[1]*r[1]+e[2]*r[2]}function requireAngle$1(){if(B)return I;B=1;const e=requireDot$2();return I=(r,t)=>{const n=r[0],o=r[1],i=r[2],s=t[0],u=t[1],a=t[2],c=Math.sqrt(n*n+o*o+i*i)*Math.sqrt(s*s+u*u+a*a),l=c&&e(r,t)/c;return Math.acos(Math.min(Math.max(l,-1),1))}}function requireCreate$b(){if(j)return D;j=1;return D=()=>[0,0,0]}function requireClone$8(){if(_)return L;_=1;const e=requireCreate$b();return L=r=>{const t=e();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t}}function requireCopy$4(){if(X)return Z;X=1;return Z=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e)}function requireCross$1(){if(H)return U;H=1;return U=(e,r,t)=>{const n=r[0],o=r[1],i=r[2],s=t[0],u=t[1],a=t[2];return e[0]=o*a-i*u,e[1]=i*s-n*a,e[2]=n*u-o*s,e}}function requireDistance$1(){if(W)return Y;W=1;return Y=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1],o=r[2]-e[2];return Math.sqrt(t*t+n*n+o*o)}}function requireDivide$1(){if(Q)return J;Q=1;return J=(e,r,t)=>(e[0]=r[0]/t[0],e[1]=r[1]/t[1],e[2]=r[2]/t[2],e)}function requireEquals$6(){if(ee)return K;ee=1;return K=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]}function requireFromScalar$2(){if(te)return re;te=1;return re=(e,r)=>(e[0]=r,e[1]=r,e[2]=r,e)}function requireFromValues$3(){if(oe)return ne;oe=1;const e=requireCreate$b();return ne=(r,t,n)=>{const o=e();return o[0]=r,o[1]=t,o[2]=n,o}}function requireFromVec2(){if(se)return ie;se=1;return ie=(e,r,t=0)=>(e[0]=r[0],e[1]=r[1],e[2]=t,e)}function requireLength$2(){if(ae)return ue;ae=1;return ue=e=>{const r=e[0],t=e[1],n=e[2];return Math.sqrt(r*r+t*t+n*n)}}function requireLerp$1(){if(le)return ce;le=1;return ce=(e,r,t,n)=>(e[0]=r[0]+n*(t[0]-r[0]),e[1]=r[1]+n*(t[1]-r[1]),e[2]=r[2]+n*(t[2]-r[2]),e)}function requireMax$1(){if(he)return fe;he=1;return fe=(e,r,t)=>(e[0]=Math.max(r[0],t[0]),e[1]=Math.max(r[1],t[1]),e[2]=Math.max(r[2],t[2]),e)}function requireMin$1(){if(de)return ge;de=1;return ge=(e,r,t)=>(e[0]=Math.min(r[0],t[0]),e[1]=Math.min(r[1],t[1]),e[2]=Math.min(r[2],t[2]),e)}function requireMultiply$2(){if(qe)return me;qe=1;return me=(e,r,t)=>(e[0]=r[0]*t[0],e[1]=r[1]*t[1],e[2]=r[2]*t[2],e)}function requireNegate$1(){if(ye)return pe;ye=1;return pe=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e[2]=-r[2],e)}function requireNormalize$1(){if(we)return ve;we=1;return ve=(e,r)=>{const t=r[0],n=r[1],o=r[2];let i=t*t+n*n+o*o;return i>0&&(i=1/Math.sqrt(i)),e[0]=t*i,e[1]=n*i,e[2]=o*i,e}}function requireOrthogonal(){if(xe)return be;xe=1;const e=requireAbs$1(),r=requireCreate$b(),t=requireCross$1();return be=(n,o)=>{const i=e(r(),o),s=0+(i[0]<i[1]&&i[0]<i[2]),u=0+(i[1]<=i[0]&&i[1]<i[2]),a=0+(i[2]<=i[0]&&i[2]<=i[1]);return t(n,o,[s,u,a])}}function requireRotateX$1(){if(Ae)return Ee;Ae=1;return Ee=(e,r,t,n)=>{const o=[],i=[];return o[0]=r[0]-t[0],o[1]=r[1]-t[1],o[2]=r[2]-t[2],i[0]=o[0],i[1]=o[1]*Math.cos(n)-o[2]*Math.sin(n),i[2]=o[1]*Math.sin(n)+o[2]*Math.cos(n),e[0]=i[0]+t[0],e[1]=i[1]+t[1],e[2]=i[2]+t[2],e}}function requireRotateY$1(){if(Pe)return $e;Pe=1;return $e=(e,r,t,n)=>{const o=[],i=[];return o[0]=r[0]-t[0],o[1]=r[1]-t[1],o[2]=r[2]-t[2],i[0]=o[2]*Math.sin(n)+o[0]*Math.cos(n),i[1]=o[1],i[2]=o[2]*Math.cos(n)-o[0]*Math.sin(n),e[0]=i[0]+t[0],e[1]=i[1]+t[1],e[2]=i[2]+t[2],e}}function requireRotateZ$1(){if(Te)return Me;Te=1;return Me=(e,r,t,n)=>{const o=[],i=[];return o[0]=r[0]-t[0],o[1]=r[1]-t[1],i[0]=o[0]*Math.cos(n)-o[1]*Math.sin(n),i[1]=o[0]*Math.sin(n)+o[1]*Math.cos(n),e[0]=i[0]+t[0],e[1]=i[1]+t[1],e[2]=r[2],e}}function requireScale$3(){if(Se)return Ce;Se=1;return Ce=(e,r,t)=>(e[0]=r[0]*t,e[1]=r[1]*t,e[2]=r[2]*t,e)}function requireSnap$2(){if(Ve)return Fe;Ve=1;return Fe=(e,r,t)=>(e[0]=Math.round(r[0]/t)*t+0,e[1]=Math.round(r[1]/t)*t+0,e[2]=Math.round(r[2]/t)*t+0,e)}function requireSquaredDistance$1(){if(Ge)return Re;Ge=1;return Re=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1],o=r[2]-e[2];return t*t+n*n+o*o}}function requireSquaredLength$1(){if(Ne)return ke;Ne=1;return ke=e=>{const r=e[0],t=e[1],n=e[2];return r*r+t*t+n*n}}function requireSubtract$3(){if(ze)return Oe;ze=1;return Oe=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e[2]=r[2]-t[2],e)}function requireToString$a(){if(Be)return Ie;Be=1;return Ie=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`}function requireTransform$b(){if(je)return De;je=1;return De=(e,r,t)=>{const n=r[0],o=r[1],i=r[2];let s=t[3]*n+t[7]*o+t[11]*i+t[15];return s=s||1,e[0]=(t[0]*n+t[4]*o+t[8]*i+t[12])/s,e[1]=(t[1]*n+t[5]*o+t[9]*i+t[13])/s,e[2]=(t[2]*n+t[6]*o+t[10]*i+t[14])/s,e}}function requireVec3(){return _e?Le:(_e=1,Le={abs:requireAbs$1(),add:requireAdd$1(),angle:requireAngle$1(),clone:requireClone$8(),copy:requireCopy$4(),create:requireCreate$b(),cross:requireCross$1(),distance:requireDistance$1(),divide:requireDivide$1(),dot:requireDot$2(),equals:requireEquals$6(),fromScalar:requireFromScalar$2(),fromValues:requireFromValues$3(),fromVec2:requireFromVec2(),length:requireLength$2(),lerp:requireLerp$1(),max:requireMax$1(),min:requireMin$1(),multiply:requireMultiply$2(),negate:requireNegate$1(),normalize:requireNormalize$1(),orthogonal:requireOrthogonal(),rotateX:requireRotateX$1(),rotateY:requireRotateY$1(),rotateZ:requireRotateZ$1(),scale:requireScale$3(),snap:requireSnap$2(),squaredDistance:requireSquaredDistance$1(),squaredLength:requireSquaredLength$1(),subtract:requireSubtract$3(),toString:requireToString$a(),transform:requireTransform$b()})}function requireFromVectorRotation(){if(Xe)return Ze;Xe=1;const e=requireVec3(),r=requireFromRotation();return Ze=(t,n,o)=>{const i=e.normalize(e.create(),n),s=e.normalize(e.create(),o),u=e.cross(e.create(),s,i),a=e.dot(s,i);if(-1===a)return r(t,Math.PI,e.orthogonal(u,i));const c=1/(1+a);return t[0]=u[0]*u[0]*c+a,t[1]=u[1]*u[0]*c-u[2],t[2]=u[2]*u[0]*c+u[1],t[3]=0,t[4]=u[0]*u[1]*c+u[2],t[5]=u[1]*u[1]*c+a,t[6]=u[2]*u[1]*c-u[0],t[7]=0,t[8]=u[0]*u[2]*c-u[1],t[9]=u[1]*u[2]*c+u[0],t[10]=u[2]*u[2]*c+a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}}function requireFromXRotation(){if(He)return Ue;He=1;const{sin:e,cos:r}=requireTrigonometry();return Ue=(t,n)=>{const o=e(n),i=r(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=o,t[7]=0,t[8]=0,t[9]=-o,t[10]=i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}}function requireFromYRotation(){if(We)return Ye;We=1;const{sin:e,cos:r}=requireTrigonometry();return Ye=(t,n)=>{const o=e(n),i=r(n);return t[0]=i,t[1]=0,t[2]=-o,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=o,t[9]=0,t[10]=i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}}function requireFromZRotation(){if(Qe)return Je;Qe=1;const{sin:e,cos:r}=requireTrigonometry();return Je=(t,n)=>{const o=e(n),i=r(n);return t[0]=i,t[1]=o,t[2]=0,t[3]=0,t[4]=-o,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}}function requireIsIdentity(){if(er)return Ke;er=1;return Ke=e=>1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&0===e[4]&&1===e[5]&&0===e[6]&&0===e[7]&&0===e[8]&&0===e[9]&&1===e[10]&&0===e[11]&&0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]}function requireIsOnlyTransformScale(){if(tr)return rr;tr=1;const isZero=e=>Math.abs(e)<Number.EPSILON;return rr=e=>isZero(e[1])&&isZero(e[2])&&isZero(e[3])&&isZero(e[4])&&isZero(e[6])&&isZero(e[7])&&isZero(e[8])&&isZero(e[9])&&isZero(e[11])&&1===e[15]}function requireIsMirroring(){if(or)return nr;or=1;return nr=e=>{const r=e[4]*e[9]-e[8]*e[5],t=e[8]*e[1]-e[0]*e[9],n=e[0]*e[5]-e[4]*e[1];return r*e[2]+t*e[6]+n*e[10]<0}}function requireMirrorByPlane(){if(sr)return ir;sr=1;return ir=(e,r)=>{const[t,n,o,i]=r;return e[0]=1-2*t*t,e[1]=-2*n*t,e[2]=-2*o*t,e[3]=0,e[4]=-2*t*n,e[5]=1-2*n*n,e[6]=-2*o*n,e[7]=0,e[8]=-2*t*o,e[9]=-2*n*o,e[10]=1-2*o*o,e[11]=0,e[12]=2*t*i,e[13]=2*n*i,e[14]=2*o*i,e[15]=1,e},ir}function requireMultiply$1(){if(ar)return ur;ar=1;return ur=(e,r,t)=>{const n=r[0],o=r[1],i=r[2],s=r[3],u=r[4],a=r[5],c=r[6],l=r[7],f=r[8],h=r[9],g=r[10],d=r[11],m=r[12],q=r[13],p=r[14],y=r[15];let v=t[0],w=t[1],b=t[2],x=t[3];return e[0]=v*n+w*u+b*f+x*m,e[1]=v*o+w*a+b*h+x*q,e[2]=v*i+w*c+b*g+x*p,e[3]=v*s+w*l+b*d+x*y,v=t[4],w=t[5],b=t[6],x=t[7],e[4]=v*n+w*u+b*f+x*m,e[5]=v*o+w*a+b*h+x*q,e[6]=v*i+w*c+b*g+x*p,e[7]=v*s+w*l+b*d+x*y,v=t[8],w=t[9],b=t[10],x=t[11],e[8]=v*n+w*u+b*f+x*m,e[9]=v*o+w*a+b*h+x*q,e[10]=v*i+w*c+b*g+x*p,e[11]=v*s+w*l+b*d+x*y,v=t[12],w=t[13],b=t[14],x=t[15],e[12]=v*n+w*u+b*f+x*m,e[13]=v*o+w*a+b*h+x*q,e[14]=v*i+w*c+b*g+x*p,e[15]=v*s+w*l+b*d+x*y,e}}function requireRotate$2(){if(lr)return cr;lr=1;const{EPS:e}=requireConstants(),{sin:r,cos:t}=requireTrigonometry(),n=requireCopy$5();return cr=(o,i,s,u)=>{let[a,c,l]=u;const f=a*a+c*c+l*l;if(Math.abs(f)<e)return n(o,i);const h=1/Math.sqrt(f);a*=h,c*=h,l*=h;const g=r(s),d=t(s),m=1-d,q=i[0],p=i[1],y=i[2],v=i[3],w=i[4],b=i[5],x=i[6],E=i[7],A=i[8],$=i[9],P=i[10],M=i[11],T=a*a*m+d,C=c*a*m+l*g,S=l*a*m-c*g,F=a*c*m-l*g,V=c*c*m+d,R=l*c*m+a*g,G=a*l*m+c*g,k=c*l*m-a*g,N=l*l*m+d;return o[0]=q*T+w*C+A*S,o[1]=p*T+b*C+$*S,o[2]=y*T+x*C+P*S,o[3]=v*T+E*C+M*S,o[4]=q*F+w*V+A*R,o[5]=p*F+b*V+$*R,o[6]=y*F+x*V+P*R,o[7]=v*F+E*V+M*R,o[8]=q*G+w*k+A*N,o[9]=p*G+b*k+$*N,o[10]=y*G+x*k+P*N,o[11]=v*G+E*k+M*N,i!==o&&(o[12]=i[12],o[13]=i[13],o[14]=i[14],o[15]=i[15]),o}}function requireRotateX(){if(hr)return fr;hr=1;const{sin:e,cos:r}=requireTrigonometry();return fr=(t,n,o)=>{const i=e(o),s=r(o),u=n[4],a=n[5],c=n[6],l=n[7],f=n[8],h=n[9],g=n[10],d=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=u*s+f*i,t[5]=a*s+h*i,t[6]=c*s+g*i,t[7]=l*s+d*i,t[8]=f*s-u*i,t[9]=h*s-a*i,t[10]=g*s-c*i,t[11]=d*s-l*i,t}}function requireRotateY(){if(dr)return gr;dr=1;const{sin:e,cos:r}=requireTrigonometry();return gr=(t,n,o)=>{const i=e(o),s=r(o),u=n[0],a=n[1],c=n[2],l=n[3],f=n[8],h=n[9],g=n[10],d=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*s-f*i,t[1]=a*s-h*i,t[2]=c*s-g*i,t[3]=l*s-d*i,t[8]=u*i+f*s,t[9]=a*i+h*s,t[10]=c*i+g*s,t[11]=l*i+d*s,t}}function requireRotateZ(){if(qr)return mr;qr=1;const{sin:e,cos:r}=requireTrigonometry();return mr=(t,n,o)=>{const i=e(o),s=r(o),u=n[0],a=n[1],c=n[2],l=n[3],f=n[4],h=n[5],g=n[6],d=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*s+f*i,t[1]=a*s+h*i,t[2]=c*s+g*i,t[3]=l*s+d*i,t[4]=f*s-u*i,t[5]=h*s-a*i,t[6]=g*s-c*i,t[7]=d*s-l*i,t}}function requireScale$2(){if(yr)return pr;yr=1;return pr=(e,r,t)=>{const n=t[0],o=t[1],i=t[2];return e[0]=r[0]*n,e[1]=r[1]*n,e[2]=r[2]*n,e[3]=r[3]*n,e[4]=r[4]*o,e[5]=r[5]*o,e[6]=r[6]*o,e[7]=r[7]*o,e[8]=r[8]*i,e[9]=r[9]*i,e[10]=r[10]*i,e[11]=r[11]*i,e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e}}function requireSubtract$2(){if(wr)return vr;wr=1;return vr=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e[2]=r[2]-t[2],e[3]=r[3]-t[3],e[4]=r[4]-t[4],e[5]=r[5]-t[5],e[6]=r[6]-t[6],e[7]=r[7]-t[7],e[8]=r[8]-t[8],e[9]=r[9]-t[9],e[10]=r[10]-t[10],e[11]=r[11]-t[11],e[12]=r[12]-t[12],e[13]=r[13]-t[13],e[14]=r[14]-t[14],e[15]=r[15]-t[15],e)}function requireToString$9(){if(xr)return br;xr=1;return br=e=>e.map(e=>e.toFixed(7)).toString()}function requireTranslate$1(){if(Ar)return Er;Ar=1;return Er=(e,r,t)=>{const n=t[0],o=t[1],i=t[2];let s,u,a,c,l,f,h,g,d,m,q,p;return r===e?(e[12]=r[0]*n+r[4]*o+r[8]*i+r[12],e[13]=r[1]*n+r[5]*o+r[9]*i+r[13],e[14]=r[2]*n+r[6]*o+r[10]*i+r[14],e[15]=r[3]*n+r[7]*o+r[11]*i+r[15]):(s=r[0],u=r[1],a=r[2],c=r[3],l=r[4],f=r[5],h=r[6],g=r[7],d=r[8],m=r[9],q=r[10],p=r[11],e[0]=s,e[1]=u,e[2]=a,e[3]=c,e[4]=l,e[5]=f,e[6]=h,e[7]=g,e[8]=d,e[9]=m,e[10]=q,e[11]=p,e[12]=s*n+l*o+d*i+r[12],e[13]=u*n+f*o+m*i+r[13],e[14]=a*n+h*o+q*i+r[14],e[15]=c*n+g*o+p*i+r[15]),e}}function requireMat4(){return Pr?$r:(Pr=1,$r={add:requireAdd$2(),clone:requireClone$9(),copy:requireCopy$5(),create:requireCreate$c(),invert:requireInvert$2(),equals:requireEquals$7(),fromRotation:requireFromRotation(),fromScaling:requireFromScaling(),fromTaitBryanRotation:requireFromTaitBryanRotation(),fromTranslation:requireFromTranslation(),fromValues:requireFromValues$4(),fromVectorRotation:requireFromVectorRotation(),fromXRotation:requireFromXRotation(),fromYRotation:requireFromYRotation(),fromZRotation:requireFromZRotation(),identity:requireIdentity(),isIdentity:requireIsIdentity(),isOnlyTransformScale:requireIsOnlyTransformScale(),isMirroring:requireIsMirroring(),mirrorByPlane:requireMirrorByPlane(),multiply:requireMultiply$1(),rotate:requireRotate$2(),rotateX:requireRotateX(),rotateY:requireRotateY(),rotateZ:requireRotateZ(),scale:requireScale$2(),subtract:requireSubtract$2(),toString:requireToString$9(),translate:requireTranslate$1()})}function requireCreate$a(){if(Tr)return Mr;Tr=1;const e=requireMat4();return Mr=r=>(void 0===r&&(r=[]),{sides:r,transforms:e.create()})}function requireAbs(){if(Sr)return Cr;Sr=1;return Cr=(e,r)=>(e[0]=Math.abs(r[0]),e[1]=Math.abs(r[1]),e)}function requireAdd(){if(Vr)return Fr;Vr=1;return Fr=(e,r,t)=>(e[0]=r[0]+t[0],e[1]=r[1]+t[1],e)}function requireAngleRadians(){if(Gr)return Rr;Gr=1;return Rr=e=>Math.atan2(e[1],e[0])}function requireAngleDegrees(){if(zr)return Or;zr=1;const e=requireAngleRadians();return Or=r=>57.29577951308232*e(r)}function requireCreate$9(){if(Br)return Ir;Br=1;return Ir=()=>[0,0]}function requireClone$7(){if(jr)return Dr;jr=1;const e=requireCreate$9();return Dr=r=>{const t=e();return t[0]=r[0],t[1]=r[1],t}}function requireCopy$3(){if(_r)return Lr;_r=1;return Lr=(e,r)=>(e[0]=r[0],e[1]=r[1],e)}function requireCross(){if(Xr)return Zr;Xr=1;return Zr=(e,r,t)=>(e[0]=0,e[1]=0,e[2]=r[0]*t[1]-r[1]*t[0],e)}function requireDistance(){if(Hr)return Ur;Hr=1;return Ur=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1];return Math.sqrt(t*t+n*n)}}function requireDivide(){if(Wr)return Yr;Wr=1;return Yr=(e,r,t)=>(e[0]=r[0]/t[0],e[1]=r[1]/t[1],e)}function requireDot$1(){if(Qr)return Jr;Qr=1;return Jr=(e,r)=>e[0]*r[0]+e[1]*r[1]}function requireEquals$5(){if(et)return Kr;et=1;return Kr=(e,r)=>e[0]===r[0]&&e[1]===r[1]}function requireFromAngleRadians(){if(tt)return rt;tt=1;const{sin:e,cos:r}=requireTrigonometry();return rt=(t,n)=>(t[0]=r(n),t[1]=e(n),t)}function requireFromAngleDegrees(){if(ot)return nt;ot=1;const e=requireFromAngleRadians();return nt=(r,t)=>e(r,.017453292519943295*t)}function requireFromScalar$1(){if(st)return it;st=1;return it=(e,r)=>(e[0]=r,e[1]=r,e)}function requireFromValues$2(){if(at)return ut;at=1;const e=requireCreate$9();return ut=(r,t)=>{const n=e();return n[0]=r,n[1]=t,n}}function requireLength$1(){if(lt)return ct;lt=1;return ct=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1])}function requireLerp(){if(ht)return ft;ht=1;return ft=(e,r,t,n)=>{const o=r[0],i=r[1];return e[0]=o+n*(t[0]-o),e[1]=i+n*(t[1]-i),e}}function requireMax(){if(dt)return gt;dt=1;return gt=(e,r,t)=>(e[0]=Math.max(r[0],t[0]),e[1]=Math.max(r[1],t[1]),e)}function requireMin(){if(qt)return mt;qt=1;return mt=(e,r,t)=>(e[0]=Math.min(r[0],t[0]),e[1]=Math.min(r[1],t[1]),e)}function requireMultiply(){if(yt)return pt;yt=1;return pt=(e,r,t)=>(e[0]=r[0]*t[0],e[1]=r[1]*t[1],e)}function requireNegate(){if(wt)return vt;wt=1;return vt=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e)}function requireRotate$1(){if(xt)return bt;xt=1;return bt=(e,r,t,n)=>{const o=r[0]-t[0],i=r[1]-t[1],s=Math.cos(n),u=Math.sin(n);return e[0]=o*s-i*u+t[0],e[1]=o*u+i*s+t[1],e}}function requireNormal(){if(At)return Et;At=1;const{TAU:e}=requireConstants(),r=requireCreate$9(),t=requireRotate$1();return Et=(n,o)=>t(n,o,r(),e/4)}function requireNormalize(){if(Pt)return $t;Pt=1;return $t=(e,r)=>{const t=r[0],n=r[1];let o=t*t+n*n;return o>0&&(o=1/Math.sqrt(o)),e[0]=t*o,e[1]=n*o,e}}function requireScale$1(){if(Tt)return Mt;Tt=1;return Mt=(e,r,t)=>(e[0]=r[0]*t,e[1]=r[1]*t,e)}function requireSnap$1(){if(St)return Ct;St=1;return Ct=(e,r,t)=>(e[0]=Math.round(r[0]/t)*t+0,e[1]=Math.round(r[1]/t)*t+0,e)}function requireSquaredDistance(){if(Vt)return Ft;Vt=1;return Ft=(e,r)=>{const t=r[0]-e[0],n=r[1]-e[1];return t*t+n*n}}function requireSquaredLength(){if(Gt)return Rt;Gt=1;return Rt=e=>{const r=e[0],t=e[1];return r*r+t*t}}function requireSubtract$1(){if(Nt)return kt;Nt=1;return kt=(e,r,t)=>(e[0]=r[0]-t[0],e[1]=r[1]-t[1],e)}function requireToString$8(){if(zt)return Ot;zt=1;return Ot=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`}function requireTransform$a(){if(Bt)return It;Bt=1;return It=(e,r,t)=>{const n=r[0],o=r[1];return e[0]=t[0]*n+t[4]*o+t[12],e[1]=t[1]*n+t[5]*o+t[13],e}}function requireVec2(){return jt?Dt:(jt=1,Dt={abs:requireAbs(),add:requireAdd(),angle:Nr?kr:(Nr=1,kr=requireAngleRadians()),angleDegrees:requireAngleDegrees(),angleRadians:requireAngleRadians(),clone:requireClone$7(),copy:requireCopy$3(),create:requireCreate$9(),cross:requireCross(),distance:requireDistance(),divide:requireDivide(),dot:requireDot$1(),equals:requireEquals$5(),fromAngleDegrees:requireFromAngleDegrees(),fromAngleRadians:requireFromAngleRadians(),fromScalar:requireFromScalar$1(),fromValues:requireFromValues$2(),length:requireLength$1(),lerp:requireLerp(),max:requireMax(),min:requireMin(),multiply:requireMultiply(),negate:requireNegate(),normal:requireNormal(),normalize:requireNormalize(),rotate:requireRotate$1(),scale:requireScale$1(),snap:requireSnap$1(),squaredDistance:requireSquaredDistance(),squaredLength:requireSquaredLength(),subtract:requireSubtract$1(),toString:requireToString$8(),transform:requireTransform$a()})}function requireFromPoints$7(){if(_t)return Lt;_t=1;const e=requireVec2(),r=requireCreate$a();return Lt=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");let n=t.length;if(n<3)throw new Error("the given points must define a closed geometry with three or more points");e.equals(t[0],t[n-1])&&--n;const o=[];let i=t[n-1];for(let r=0;r<n;r++){const n=t[r];o.push([e.clone(i),e.clone(n)]),i=n}return r(o)}}function requireFromCompactBinary$2(){if(Xt)return Zt;Xt=1;const e=requireMat4(),r=requireVec2(),t=requireCreate$a();return Zt=n=>{if(0!==n[0])throw new Error("invalid compact binary data");const o=t();o.transforms=e.clone(n.slice(1,17));for(let e=21;e<n.length;e+=4){const t=r.fromValues(n[e+0],n[e+1]),i=r.fromValues(n[e+2],n[e+3]);o.sides.push([t,i])}return n[17]>=0&&(o.color=[n[17],n[18],n[19],n[20]]),o}}function requireIsA$4(){if(Ht)return Ut;Ht=1;return Ut=e=>!!(e&&"object"==typeof e&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms)}function requireToSides(){if(Qt)return Jt;Qt=1;const e=function requireApplyTransforms$2(){if(Wt)return Yt;Wt=1;const e=requireMat4(),r=requireVec2();return Yt=t=>(e.isIdentity(t.transforms)||(t.sides=t.sides.map(e=>[r.transform(r.create(),e[0],t.transforms),r.transform(r.create(),e[1],t.transforms)]),t.transforms=e.create()),t)}();return Jt=r=>e(r).sides}function requireReverse$4(){if(en)return Kt;en=1;const e=requireCreate$a(),r=requireToSides();return Kt=t=>{const n=r(t).map(e=>[e[1],e[0]]);return n.reverse(),e(n)}}function requireToOutlines(){if(tn)return rn;tn=1;const e=requireVec2(),r=requireToSides(),toVertexMap=e=>{const r=new Map,t=(e=>{const r=new Map,getUniqueVertex=e=>{const t=e.toString();return r.has(t)?r.get(t):(r.set(t,e),e)};return e.map(e=>e.map(getUniqueVertex))})(e);return t.forEach(e=>{r.has(e[0])?r.get(e[0]).push(e):r.set(e[0],[e])}),r},popNextSide=(r,t)=>{if(1===t.length)return t.pop();const n=e.create(),o=e.angleDegrees(e.subtract(n,r[1],r[0]));let i,s;t.forEach((r,t)=>{let u=e.angleDegrees(e.subtract(n,r[1],r[0]))-o;u<-180&&(u+=360),u>=180&&(u-=360),(void 0===s||u>i)&&(s=t,i=u)});const u=t[s];return t.splice(s,1),u};return rn=e=>{const t=toVertexMap(r(e)),n=[];for(;;){let e;for(const[r,n]of t){if(e=n.shift(),e)break;t.delete(r)}if(void 0===e)break;const r=[],o=e[0];for(;;){r.push(e[0]);const n=e[1];if(n===o)break;const i=t.get(n);if(!i)throw new Error(`geometry is not closed at vertex ${n}`);const s=popNextSide(e,i);0===i.length&&t.delete(n),e=s}r.length>0&&r.push(r.shift()),n.push(r)}return t.clear(),n}}function requireToPoints$3(){if(on)return nn;on=1;const e=requireToSides();return nn=r=>{const t=e(r).map(e=>e[0]);return t.length>0&&t.push(t.shift()),t}}function requireToString$7(){if(un)return sn;un=1;const e=requireVec2(),r=requireToSides();return sn=t=>{const n=r(t);let o="geom2 ("+n.length+" sides):\n[\n";return n.forEach(r=>{o+="  ["+e.toString(r[0])+", "+e.toString(r[1])+"]\n"}),o+="]\n",o}}function requireToCompactBinary$2(){if(cn)return an;cn=1;return an=e=>{const r=e.sides,t=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const o=new Float32Array(21+4*r.length);o[0]=0,o[1]=t[0],o[2]=t[1],o[3]=t[2],o[4]=t[3],o[5]=t[4],o[6]=t[5],o[7]=t[6],o[8]=t[7],o[9]=t[8],o[10]=t[9],o[11]=t[10],o[12]=t[11],o[13]=t[12],o[14]=t[13],o[15]=t[14],o[16]=t[15],o[17]=n[0],o[18]=n[1],o[19]=n[2],o[20]=n[3];for(let e=0;e<r.length;e++){const t=4*e+21,n=r[e][0],i=r[e][1];o[t+0]=n[0],o[t+1]=n[1],o[t+2]=i[0],o[t+3]=i[1]}return o},an}function requireTransform$9(){if(fn)return ln;fn=1;const e=requireMat4(),r=requireReverse$4();return ln=(t,n)=>{const o=e.multiply(e.create(),t,n.transforms),i=Object.assign({},n,{transforms:o});return t[0]*t[5]-t[4]*t[1]<0?r(i):i},ln}function requireValidate$3(){if(gn)return hn;gn=1;const e=requireVec2(),r=requireIsA$4(),t=requireToOutlines();return hn=n=>{if(!r(n))throw new Error("invalid geom2 structure");if(t(n),n.sides.forEach(r=>{if(e.equals(r[0],r[1]))throw new Error(`geom2 self-edge ${r[0]}`)}),!n.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${n.transforms}`)}}function requireGeom2(){return mn?dn:(mn=1,dn={clone:requireClone$a(),create:requireCreate$a(),fromPoints:requireFromPoints$7(),fromCompactBinary:requireFromCompactBinary$2(),isA:requireIsA$4(),reverse:requireReverse$4(),toOutlines:requireToOutlines(),toPoints:requireToPoints$3(),toSides:requireToSides(),toString:requireToString$7(),toCompactBinary:requireToCompactBinary$2(),transform:requireTransform$9(),validate:requireValidate$3()})}function requireClone$6(){if(pn)return qn;pn=1;return qn=e=>Object.assign({},e)}function requireCreate$8(){if(vn)return yn;vn=1;const e=requireMat4();return yn=r=>(void 0===r&&(r=[]),{polygons:r,transforms:e.create()})}function requirePointLineDistance(){if(bn)return wn;bn=1;const e=requireCross$1(),r=requireSubtract$3(),t=requireSquaredLength$1();return wn=(n,o,i)=>Math.sqrt(((n,o,i)=>{const s=[],u=[];r(s,i,o),r(u,n,o);const a=t(e([],u,s)),c=t(s);if(0===c)throw Error("a and b are the same point");return a/c})(n,o,i))}function requireGetPlaneNormal(){if(En)return xn;En=1;const e=requireCross$1(),r=requireNormalize$1(),t=requireSubtract$3();return xn=(n,o,i,s)=>{const u=[0,0,0];return t(n,o,i),t(u,i,s),e(n,n,u),r(n,n)}}function requireFace(){if(Fn)return Sn;Fn=1;const e=requireAdd$1(),r=requireCopy$4(),t=requireCross$1(),n=requireDot$2(),o=requireLength$2(),i=requireNormalize$1(),s=requireScale$3(),u=requireSubtract$3(),a=function requireHalfEdge(){if(Cn)return Tn;Cn=1;const e=requireDistance$1(),r=requireSquaredDistance$1();return Tn=class HalfEdge{constructor(e,r){this.vertex=e,this.face=r,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?e(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?r(this.tail().point,this.head().point):-1}setOpposite(e){this.opposite=e,e.opposite=this}}}();class Face{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=0,this.edge=null,this.nVertices=0}getEdge(e){if("number"!=typeof e)throw Error("requires a number");let r=this.edge;for(;e>0;)r=r.next,e-=1;for(;e<0;)r=r.prev,e+=1;return r}computeNormal(){const n=this.edge,i=n.next;let a=i.next;const c=u([],i.head().point,n.head().point),l=[],f=[];for(this.nVertices=2,this.normal=[0,0,0];a!==n;)r(f,c),u(c,a.head().point,n.head().point),e(this.normal,this.normal,t(l,f,c)),a=a.next,this.nVertices+=1;this.area=o(this.normal),this.normal=s(this.normal,this.normal,1/this.area)}computeNormalMinArea(r){if(this.computeNormal(),this.area<r){let r,t=0,o=this.edge;do{const e=o.lengthSquared();e>t&&(r=o,t=e),o=o.next}while(o!==this.edge);const a=r.tail().point,c=r.head().point,l=u([],c,a),f=Math.sqrt(t);s(l,l,1/f);const h=n(this.normal,l);s(l,l,-h),e(this.normal,this.normal,l),i(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let r=this.edge;do{e(this.centroid,this.centroid,r.head().point),r=r.next}while(r!==this.edge);s(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(e){void 0!==e?this.computeNormalMinArea(e):this.computeNormal(),this.computeCentroid(),this.offset=n(this.normal,this.centroid)}distanceToPlane(e){return n(this.normal,e)-this.offset}connectHalfEdges(e,r){let t;if(e.opposite.face===r.opposite.face){const n=r.opposite.face;let o;e===this.edge&&(this.edge=r),3===n.nVertices?(o=r.opposite.prev.opposite,n.mark=2,t=n):(o=r.opposite.next,n.edge===o.prev&&(n.edge=o),o.prev=o.prev.prev,o.prev.next=o),r.prev=e.prev,r.prev.next=r,r.setOpposite(o),n.computeNormalAndCentroid()}else e.next=r,r.prev=e;return t}mergeAdjacentFaces(e,r){const t=e.opposite,n=t.face;r.push(n),n.mark=2;let o,i,s=e.prev,u=e.next,a=t.prev,c=t.next;for(;s.opposite.face===n;)s=s.prev,c=c.next;for(;u.opposite.face===n;)u=u.next,a=a.prev;for(o=c;o!==a.next;o=o.next)o.face=this;return this.edge=u,i=this.connectHalfEdges(a,u),i&&r.push(i),i=this.connectHalfEdges(s,c),i&&r.push(i),this.computeNormalAndCentroid(),r}collectIndices(){const e=[];let r=this.edge;do{e.push(r.head().index),r=r.next}while(r!==this.edge);return e}static createTriangle(e,r,t,n=0){const o=new Face,i=new a(e,o),s=new a(r,o),u=new a(t,o);return i.next=u.prev=s,s.next=i.prev=u,u.next=s.prev=i,o.edge=i,o.computeNormalAndCentroid(n),o}}return Sn={VISIBLE:0,NON_CONVEX:1,DELETED:2,Face:Face}}function requireQuickHull(){if(Rn)return Vn;Rn=1;const e=requireDot$2(),r=requirePointLineDistance(),t=requireGetPlaneNormal(),n=function requireVertexList(){return $n?An:($n=1,An=class VertexList{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(e,r){r.prev=e.prev,r.next=e,r.prev?r.prev.next=r:this.head=r,e.prev=r}insertAfter(e,r){r.prev=e,r.next=e.next,r.next?r.next.prev=r:this.tail=r,e.next=r}add(e){this.head?this.tail.next=e:this.head=e,e.prev=this.tail,e.next=null,this.tail=e}addAll(e){for(this.head?this.tail.next=e:this.head=e,e.prev=this.tail;e.next;)e=e.next;this.tail=e}remove(e){e.prev?e.prev.next=e.next:this.head=e.next,e.next?e.next.prev=e.prev:this.tail=e.prev}removeChain(e,r){e.prev?e.prev.next=r.next:this.head=r.next,r.next?r.next.prev=e.prev:this.tail=e.prev}first(){return this.head}isEmpty(){return!this.head}})}(),o=function requireVertex(){return Mn?Pn:(Mn=1,Pn=class Vertex{constructor(e,r){this.point=e,this.index=r,this.next=null,this.prev=null,this.face=null}})}(),{Face:i,VISIBLE:s,NON_CONVEX:u,DELETED:a}=requireFace();return Vn=class QuickHull{constructor(e){if(!Array.isArray(e))throw TypeError("input is not a valid array");if(e.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=e.length,this.faces=[],this.newFaces=[],this.claimed=new n,this.unclaimed=new n,this.vertices=[];for(let r=0;r<e.length;r+=1)this.vertices.push(new o(e[r],r));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(e,r){e.face=r,r.outside?this.claimed.insertBefore(r.outside,e):this.claimed.add(e),r.outside=e}removeVertexFromFace(e,r){e===r.outside&&(e.next&&e.next.face===r?r.outside=e.next:r.outside=null),this.claimed.remove(e)}removeAllVerticesFromFace(e){if(e.outside){let r=e.outside;for(;r.next&&r.next.face===e;)r=r.next;return this.claimed.removeChain(e.outside,r),r.next=null,e.outside}}deleteFaceVertices(e,r){const t=this.removeAllVerticesFromFace(e);if(t)if(r){let e;for(let n=t;n;n=e){e=n.next;r.distanceToPlane(n.point)>this.tolerance?this.addVertexToFace(n,r):this.unclaimed.add(n)}}else this.unclaimed.addAll(t)}resolveUnclaimedPoints(e){let r=this.unclaimed.first();for(let t=r;t;t=r){r=t.next;let n,o=this.tolerance;for(let r=0;r<e.length;r+=1){const i=e[r];if(i.mark===s){const e=i.distanceToPlane(t.point);if(e>o&&(o=e,n=i),o>1e3*this.tolerance)break}}n&&this.addVertexToFace(t,n)}}computeExtremes(){const e=[],r=[],t=[],n=[];let o,i;for(o=0;o<3;o+=1)t[o]=n[o]=this.vertices[0];for(o=0;o<3;o+=1)e[o]=r[o]=this.vertices[0].point[o];for(o=1;o<this.vertices.length;o+=1){const s=this.vertices[o],u=s.point;for(i=0;i<3;i+=1)u[i]<e[i]&&(e[i]=u[i],t[i]=s);for(i=0;i<3;i+=1)u[i]>r[i]&&(r[i]=u[i],n[i]=s)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e[0]),Math.abs(r[0]))+Math.max(Math.abs(e[1]),Math.abs(r[1]))+Math.max(Math.abs(e[2]),Math.abs(r[2]))),[t,n]}createInitialSimplex(){const n=this.vertices,[o,s]=this.computeExtremes();let u,a,c,l,f=0,h=0;for(c=0;c<3;c+=1){const e=s[c].point[c]-o[c].point[c];e>f&&(f=e,h=c)}const g=o[h],d=s[h];for(f=0,c=0;c<this.vertices.length;c+=1){const e=this.vertices[c];if(e!==g&&e!==d){const t=r(e.point,g.point,d.point);t>f&&(f=t,u=e)}}const m=t([],g.point,d.point,u.point),q=e(g.point,m);for(f=-1,c=0;c<this.vertices.length;c+=1){const r=this.vertices[c];if(r!==g&&r!==d&&r!==u){const t=Math.abs(e(m,r.point)-q);t>f&&(f=t,a=r)}}const p=[];if(e(a.point,m)-q<0)for(p.push(i.createTriangle(g,d,u),i.createTriangle(a,d,g),i.createTriangle(a,u,d),i.createTriangle(a,g,u)),c=0;c<3;c+=1){const e=(c+1)%3;p[c+1].getEdge(2).setOpposite(p[0].getEdge(e)),p[c+1].getEdge(1).setOpposite(p[e+1].getEdge(0))}else for(p.push(i.createTriangle(g,u,d),i.createTriangle(a,g,d),i.createTriangle(a,d,u),i.createTriangle(a,u,g)),c=0;c<3;c+=1){const e=(c+1)%3;p[c+1].getEdge(2).setOpposite(p[0].getEdge((3-c)%3)),p[c+1].getEdge(0).setOpposite(p[e+1].getEdge(1))}for(c=0;c<4;c+=1)this.faces.push(p[c]);for(c=0;c<n.length;c+=1){const e=n[c];if(e!==g&&e!==d&&e!==u&&e!==a){let r;for(f=this.tolerance,l=0;l<4;l+=1){const t=p[l].distanceToPlane(e.point);t>f&&(f=t,r=p[l])}r&&this.addVertexToFace(e,r)}}}reindexFaceAndVertices(){const e=[];for(let r=0;r<this.faces.length;r+=1){const t=this.faces[r];t.mark===s&&e.push(t)}this.faces=e}collectFaces(e){const r=[];for(let t=0;t<this.faces.length;t+=1){if(this.faces[t].mark!==s)throw Error("attempt to include a destroyed face in the hull");const n=this.faces[t].collectIndices();if(e)r.push(n);else for(let e=0;e<n.length-2;e+=1)r.push([n[0],n[e+1],n[e+2]])}return r}nextVertexToAdd(){if(!this.claimed.isEmpty()){let e,r,t=0;const n=this.claimed.first().face;for(r=n.outside;r&&r.face===n;r=r.next){const o=n.distanceToPlane(r.point);o>t&&(t=o,e=r)}return e}}computeHorizon(e,r,t,n){let o;this.deleteFaceVertices(t),t.mark=a,o=r?r.next:r=t.getEdge(0);do{const r=o.opposite,t=r.face;t.mark===s&&(t.distanceToPlane(e)>this.tolerance?this.computeHorizon(e,r,t,n):n.push(o)),o=o.next}while(o!==r)}addAdjoiningFace(e,r){const t=i.createTriangle(e,r.tail(),r.head());return this.faces.push(t),t.getEdge(-1).setOpposite(r.opposite),t.getEdge(0)}addNewFaces(e,r){let t,n;this.newFaces=[];for(let o=0;o<r.length;o+=1){const i=r[o],s=this.addAdjoiningFace(e,i);t?s.next.setOpposite(n):t=s,this.newFaces.push(s.face),n=s}t.next.setOpposite(n)}oppositeFaceDistance(e){return e.face.distanceToPlane(e.opposite.face.centroid)}doAdjacentMerge(e,r){let t=e.edge,n=!0,o=0;do{if(o>=e.nVertices)throw Error("merge recursion limit exceeded");const i=t.opposite.face;let s=!1;if(2===r?(this.oppositeFaceDistance(t)>-this.tolerance||this.oppositeFaceDistance(t.opposite)>-this.tolerance)&&(s=!0):e.area>i.area?this.oppositeFaceDistance(t)>-this.tolerance?s=!0:this.oppositeFaceDistance(t.opposite)>-this.tolerance&&(n=!1):this.oppositeFaceDistance(t.opposite)>-this.tolerance?s=!0:this.oppositeFaceDistance(t)>-this.tolerance&&(n=!1),s){const r=e.mergeAdjacentFaces(t,[]);for(let t=0;t<r.length;t+=1)this.deleteFaceVertices(r[t],e);return!0}t=t.next,o+=1}while(t!==e.edge);return n||(e.mark=u),!1}addVertexToHull(e){const r=[];this.unclaimed.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,r),this.addNewFaces(e,r);for(let e=0;e<this.newFaces.length;e+=1){const r=this.newFaces[e];if(r.mark===s)for(;this.doAdjacentMerge(r,1););}for(let e=0;e<this.newFaces.length;e+=1){const r=this.newFaces[e];if(r.mark===u)for(r.mark=s;this.doAdjacentMerge(r,2););}this.resolveUnclaimedPoints(this.newFaces)}build(){let e;for(this.createInitialSimplex();e=this.nextVertexToAdd();)this.addVertexToHull(e);this.reindexFaceAndVertices()}}}function requireQuickhull(){if(kn)return Gn;kn=1;const e=requireQuickHull();return Gn=(r,t={})=>{const n=new e(r);return n.build(),n.collectFaces(t.skipTriangulation)}}function requireCreate$7(){if(On)return Nn;On=1;return Nn=e=>((void 0===e||e.length<3)&&(e=[]),{vertices:e})}function requireClone$5(){if(In)return zn;In=1;const e=requireCreate$7(),r=requireVec3();return zn=(...t)=>{let n,o;return 1===t.length?(n=e(),o=t[0]):(n=t[0],o=t[1]),n.vertices=o.vertices.map(e=>r.clone(e)),n},zn}function requireFromPoints$6(){if(Dn)return Bn;Dn=1;const e=requireVec3(),r=requireCreate$7();return Bn=t=>{const n=t.map(r=>e.clone(r));return r(n)}}function requireFromPointsAndPlane(){if(Ln)return jn;Ln=1;const e=requireCreate$7();return jn=(r,t)=>{const n=e(r);return n.plane=t,n},jn}function requireCreate$6(){if(Zn)return _n;Zn=1;return _n=()=>[0,0,0,0]}function requireClone$4(){if(Un)return Xn;Un=1;const e=requireCreate$6();return Xn=r=>{const t=e();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t}}function requireCopy$2(){if(Yn)return Hn;Yn=1;return Hn=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e)}function requireEquals$4(){if(Jn)return Wn;Jn=1;return Wn=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]&&e[3]===r[3]}function requireFlip$1(){if(Kn)return Qn;Kn=1;return Qn=(e,r)=>(e[0]=-r[0],e[1]=-r[1],e[2]=-r[2],e[3]=-r[3],e),Qn}function requireFromNormalAndPoint(){if(ro)return eo;ro=1;const e=requireVec3();return eo=(r,t,n)=>{const o=e.normalize(e.create(),t),i=e.dot(n,o);return r[0]=o[0],r[1]=o[1],r[2]=o[2],r[3]=i,r}}function requireFromValues$1(){if(no)return to;no=1;const e=requireCreate$6();return to=(r,t,n,o)=>{const i=e();return i[0]=r,i[1]=t,i[2]=n,i[3]=o,i}}function requireFromNoisyPoints(){if(io)return oo;io=1;const e=requireVec3(),r=requireFromNormalAndPoint();return oo=(t,...n)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0;const o=n.length;n.forEach(r=>{e.add(t,t,r)}),e.scale(t,t,1/o);let i=0,s=0,u=0,a=0,c=0,l=0;const f=e.create();n.forEach(r=>{e.subtract(f,r,t),i+=f[0]*f[0],s+=f[0]*f[1],u+=f[0]*f[2],a+=f[1]*f[1],c+=f[1]*f[2],l+=f[2]*f[2]}),i/=o,s/=o,u/=o,a/=o,c/=o,l/=o,f[0]=0,f[1]=0,f[2]=0;const h=e.create();let g=a*l-c*c;h[0]=g,h[1]=u*c-s*l,h[2]=s*c-u*a;let d=g*g;return e.add(f,f,e.scale(h,h,d)),g=i*l-u*u,h[0]=u*c-s*l,h[1]=g,h[2]=s*u-c*i,d=g*g,e.dot(f,h)<0&&(d=-d),e.add(f,f,e.scale(h,h,d)),g=i*a-s*s,h[0]=s*c-u*a,h[1]=s*u-c*i,h[2]=g,d=g*g,e.dot(f,h)<0&&(d=-d),e.add(f,f,e.scale(h,h,d)),r(t,f,t)}}function requireFromPoints$5(){if(uo)return so;uo=1;const e=requireVec3();return so=(r,...t)=>{const n=t.length,o=e.create(),i=e.create(),vertexNormal=r=>{const s=t[r],u=t[(r+1)%n],a=t[(r+2)%n];return e.subtract(o,u,s),e.subtract(i,a,s),e.cross(o,o,i),e.normalize(o,o),o};return r[0]=0,r[1]=0,r[2]=0,3===n?e.copy(r,vertexNormal(0)):(t.forEach((t,n)=>{e.add(r,r,vertexNormal(n))}),e.normalize(r,r)),r[3]=e.dot(r,t[0]),r}}function requireFromPointsRandom(){if(co)return ao;co=1;const{EPS:e}=requireConstants(),r=requireVec3();return ao=(t,n,o,i)=>{let s=r.subtract(r.create(),o,n),u=r.subtract(r.create(),i,n);r.length(s)<e&&(s=r.orthogonal(s,u)),r.length(u)<e&&(u=r.orthogonal(u,s));let a=r.cross(r.create(),s,u);r.length(a)<e&&(u=r.orthogonal(u,s),a=r.cross(a,s,u)),a=r.normalize(a,a);const c=r.dot(a,n);return t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=c,t}}function requireProjectionOfPoint(){if(fo)return lo;fo=1;const e=requireVec3();return lo=(r,t)=>{const n=t[0]*r[0]+t[1]*r[1]+t[2]*r[2]-r[3],o=t[0]-n*r[0],i=t[1]-n*r[1],s=t[2]-n*r[2];return e.fromValues(o,i,s)},lo}function requireSignedDistanceToPoint(){if(go)return ho;go=1;const e=requireVec3();return ho=(r,t)=>e.dot(r,t)-r[3],ho}function requireToString$6(){if(qo)return mo;qo=1;return mo=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`}function requireTransform$8(){if(yo)return po;yo=1;const e=requireMat4(),r=requireVec3(),t=requireFromPoints$5(),n=requireFlip$1();return po=(o,i,s)=>{const u=e.isMirroring(s),a=r.orthogonal(r.create(),i),c=r.cross(a,i,a),l=r.cross(r.create(),i,c);let f=r.fromScalar(r.create(),i[3]);r.multiply(f,f,i);let h=r.add(r.create(),f,c),g=r.add(r.create(),f,l);return f=r.transform(f,f,s),h=r.transform(h,h,s),g=r.transform(g,g,s),t(o,f,h,g),u&&n(o,o),o},po}function requirePlane$1(){return wo?vo:(wo=1,vo={clone:requireClone$4(),copy:requireCopy$2(),create:requireCreate$6(),equals:requireEquals$4(),flip:requireFlip$1(),fromNormalAndPoint:requireFromNormalAndPoint(),fromValues:requireFromValues$1(),fromNoisyPoints:requireFromNoisyPoints(),fromPoints:requireFromPoints$5(),fromPointsRandom:requireFromPointsRandom(),projectionOfPoint:requireProjectionOfPoint(),signedDistanceToPoint:requireSignedDistanceToPoint(),toString:requireToString$6(),transform:requireTransform$8()})}function requireInvert$1(){if(xo)return bo;xo=1;const e=requirePlane$1(),r=requireCreate$7();return bo=t=>{const n=t.vertices.slice().reverse(),o=r(n);return t.plane&&(o.plane=e.flip(e.create(),t.plane)),o}}function requireIsA$3(){if(Ao)return Eo;Ao=1;return Eo=e=>!!(e&&"object"==typeof e&&"vertices"in e&&Array.isArray(e.vertices))}function requireIsConvex(){if(Po)return $o;Po=1;const e=requirePlane$1(),r=requireVec3(),areVerticesConvex=r=>{const t=r.length;if(t>2){const n=e.fromPoints(e.create(),...r);let o=r[t-2],i=r[t-1];for(let e=0;e<t;e++){const t=r[e];if(!isConvexPoint(o,i,t,n))return!1;o=i,i=t}}return!0},isConvexPoint=(e,t,n,o)=>{const i=r.cross(r.create(),r.subtract(r.create(),t,e),r.subtract(r.create(),n,t));return r.dot(i,o)>=0};return $o=e=>areVerticesConvex(e.vertices)}function requirePlane(){if(To)return Mo;To=1;const e=requirePlane$1();return Mo=r=>(r.plane||(r.plane=e.fromPoints(e.create(),...r.vertices)),r.plane)}function requireMeasureArea$2(){if(So)return Co;So=1;const e=requirePlane();return Co=r=>{const t=r.vertices.length;if(t<3)return 0;const n=r.vertices,o=e(r),i=Math.abs(o[0]),s=Math.abs(o[1]),u=Math.abs(o[2]);if(i+s+u===0)return 0;let a=3;i>s&&i>u?a=1:s>u&&(a=2);let c=0,l=0,f=1,h=2;switch(a){case 1:for(f=1;f<t;f++)l=f-1,h=(f+1)%t,c+=n[f][1]*(n[h][2]-n[l][2]);c+=n[0][1]*(n[1][2]-n[t-1][2]),c/=2*o[0];break;case 2:for(f=1;f<t;f++)l=f-1,h=(f+1)%t,c+=n[f][2]*(n[h][0]-n[l][0]);c+=n[0][2]*(n[1][0]-n[t-1][0]),c/=2*o[1];break;default:for(f=1;f<t;f++)l=f-1,h=(f+1)%t,c+=n[f][0]*(n[h][1]-n[l][1]);c+=n[0][0]*(n[1][1]-n[t-1][1]),c/=2*o[2]}return c}}function requireMeasureBoundingBox$1(){if(Vo)return Fo;Vo=1;const e=requireVec3();return Fo=r=>{const t=r.vertices,n=t.length,o=0===n?e.create():e.clone(t[0]),i=e.clone(o);for(let r=1;r<n;r++)e.min(o,o,t[r]),e.max(i,i,t[r]);return[o,i]}}function requireDot(){if(Go)return Ro;Go=1;return Ro=(e,r)=>e[0]*r[0]+e[1]*r[1]+e[2]*r[2]+e[3]*r[3]}function requireFromScalar(){if(No)return ko;No=1;return ko=(e,r)=>(e[0]=r,e[1]=r,e[2]=r,e[3]=r,e)}function requireTransform$7(){if(zo)return Oo;zo=1;return Oo=(e,r,t)=>{const[n,o,i,s]=r;return e[0]=t[0]*n+t[4]*o+t[8]*i+t[12]*s,e[1]=t[1]*n+t[5]*o+t[9]*i+t[13]*s,e[2]=t[2]*n+t[6]*o+t[10]*i+t[14]*s,e[3]=t[3]*n+t[7]*o+t[11]*i+t[15]*s,e}}function requireVec4(){return Bo?Io:(Bo=1,Io={clone:requireClone$4(),copy:requireCopy$2(),create:requireCreate$6(),dot:requireDot(),equals:requireEquals$4(),fromScalar:requireFromScalar(),fromValues:requireFromValues$1(),toString:requireToString$6(),transform:requireTransform$7()})}function requireMeasureBoundingSphere$1(){if(jo)return Do;jo=1;const e=requireVec4(),r=new WeakMap;return Do=t=>{const n=r.get(t);if(n)return n;const o=t.vertices,i=e.create();if(0===o.length)return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i;let s=o[0],u=s,a=s,c=s,l=s,f=s;o.forEach(e=>{s[0]>e[0]&&(s=e),u[1]>e[1]&&(u=e),a[2]>e[2]&&(a=e),c[0]<e[0]&&(c=e),l[1]<e[1]&&(l=e),f[2]<e[2]&&(f=e)}),i[0]=.5*(s[0]+c[0]),i[1]=.5*(u[1]+l[1]),i[2]=.5*(a[2]+f[2]);const h=i[0]-c[0],g=i[1]-l[1],d=i[2]-f[2];return i[3]=Math.sqrt(h*h+g*g+d*d),r.set(t,i),i}}function requireMeasureSignedVolume(){if(_o)return Lo;_o=1;const e=requireVec3();return Lo=r=>{let t=0;const n=r.vertices,o=e.create();for(let r=0;r<n.length-2;r++)e.cross(o,n[r+1],n[r+2]),t+=e.dot(n[0],o);return t/=6,t}}function requireToPoints$2(){if(Xo)return Zo;Xo=1;return Zo=e=>e.vertices}function requireToString$5(){if(Ho)return Uo;Ho=1;const e=requireVec3();return Uo=r=>{let t="poly3: vertices: [";return r.vertices.forEach(r=>{t+=`${e.toString(r)}, `}),t+="]",t}}function requireTransform$6(){if(Wo)return Yo;Wo=1;const e=requireMat4(),r=requireVec3(),t=requireCreate$7();return Yo=(n,o)=>{const i=o.vertices.map(e=>r.transform(r.create(),e,n));return e.isMirroring(n)&&i.reverse(),t(i)}}function requireValidate$2(){if(Qo)return Jo;Qo=1;const e=requireSignedDistanceToPoint(),{NEPS:r}=requireConstants(),t=requireVec3(),n=requireIsA$3(),o=requireIsConvex(),i=requireMeasureArea$2(),s=requirePlane();return Jo=u=>{if(!n(u))throw new Error("invalid poly3 structure");if(u.vertices.length<3)throw new Error(`poly3 not enough vertices ${u.vertices.length}`);if(i(u)<=0)throw new Error("poly3 area must be greater than zero");for(let e=0;e<u.vertices.length;e++)if(t.equals(u.vertices[e],u.vertices[(e+1)%u.vertices.length]))throw new Error(`poly3 duplicate vertex ${u.vertices[e]}`);if(!o(u))throw new Error("poly3 must be convex");if(u.vertices.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${e}`)}),u.vertices.length>3){const t=s(u);u.vertices.forEach(n=>{const o=Math.abs(e(t,n));if(o>r)throw new Error(`poly3 must be coplanar: vertex ${n} distance ${o}`)})}}}function requirePoly3(){return ei?Ko:(ei=1,Ko={clone:requireClone$5(),create:requireCreate$7(),fromPoints:requireFromPoints$6(),fromPointsAndPlane:requireFromPointsAndPlane(),invert:requireInvert$1(),isA:requireIsA$3(),isConvex:requireIsConvex(),measureArea:requireMeasureArea$2(),measureBoundingBox:requireMeasureBoundingBox$1(),measureBoundingSphere:requireMeasureBoundingSphere$1(),measureSignedVolume:requireMeasureSignedVolume(),plane:requirePlane(),toPoints:requireToPoints$2(),toString:requireToString$5(),transform:requireTransform$6(),validate:requireValidate$2()})}function requireFromPointsConvex(){if(ti)return ri;ti=1;const e=requireQuickhull(),r=requireCreate$8(),t=requirePoly3();return ri=n=>{if(!Array.isArray(n))throw new Error("the given points must be an array");const o=e(n,{skipTriangulation:!0}).map(e=>{const r=e.map(e=>n[e]);return t.create(r)});return r(o)}}function requireFromPoints$4(){if(oi)return ni;oi=1;const e=requirePoly3(),r=requireCreate$8();return ni=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");const n=t.map((r,t)=>e.create(r));return r(n)}}function requireFromCompactBinary$1(){if(si)return ii;si=1;const e=requireVec3(),r=requireMat4(),t=requirePoly3(),n=requireCreate$8();return ii=o=>{if(1!==o[0])throw new Error("invalid compact binary data");const i=n();i.transforms=r.clone(o.slice(1,17));const s=o[21];let u=22,a=o.length-3*s;for(;a<o.length;){const r=o[u];u++;const n=[];for(let t=0;t<r;t++)n.push(e.fromValues(o[a],o[a+1],o[a+2])),a+=3;i.polygons.push(t.create(n))}return o[17]>=0&&(i.color=[o[17],o[18],o[19],o[20]]),i}}function requireToPolygons$1(){if(li)return ci;li=1;const e=function requireApplyTransforms$1(){if(ai)return ui;ai=1;const e=requireMat4(),r=requirePoly3();return ui=t=>(e.isIdentity(t.transforms)||(t.polygons=t.polygons.map(e=>r.transform(t.transforms,e)),t.transforms=e.create()),t)}();return ci=r=>e(r).polygons}function requireInvert(){if(hi)return fi;hi=1;const e=requirePoly3(),r=requireCreate$8(),t=requireToPolygons$1();return fi=n=>{const o=t(n).map(r=>e.invert(r));return r(o)}}function requireIsA$2(){if(di)return gi;di=1;return gi=e=>!!(e&&"object"==typeof e&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms)}function requireToPoints$1(){if(qi)return mi;qi=1;const e=requirePoly3(),r=requireToPolygons$1();return mi=t=>r(t).map(r=>e.toPoints(r))}function requireToString$4(){if(yi)return pi;yi=1;const e=requirePoly3(),r=requireToPolygons$1();return pi=t=>{const n=r(t);let o="geom3 ("+n.length+" polygons):\n";return n.forEach(r=>{o+="  "+e.toString(r)+"\n"}),o}}function requireToCompactBinary$1(){if(wi)return vi;wi=1;const e=requirePoly3();return vi=r=>{const t=r.polygons,n=r.transforms,o=t.length,i=t.reduce((e,r)=>e+r.vertices.length,0);let s=[-1,-1,-1,-1];r.color&&(s=r.color);const u=new Float32Array(22+o+3*i);u[0]=1,u[1]=n[0],u[2]=n[1],u[3]=n[2],u[4]=n[3],u[5]=n[4],u[6]=n[5],u[7]=n[6],u[8]=n[7],u[9]=n[8],u[10]=n[9],u[11]=n[10],u[12]=n[11],u[13]=n[12],u[14]=n[13],u[15]=n[14],u[16]=n[15],u[17]=s[0],u[18]=s[1],u[19]=s[2],u[20]=s[3],u[21]=i;let a=22,c=a+o;return t.forEach(r=>{const t=e.toPoints(r);u[a]=t.length,a++;for(let e=0;e<t.length;e++){const r=t[e];u[c+0]=r[0],u[c+1]=r[1],u[c+2]=r[2],c+=3}}),u},vi}function requireTransform$5(){if(xi)return bi;xi=1;const e=requireMat4();return bi=(r,t)=>{const n=e.multiply(e.create(),r,t.transforms);return Object.assign({},t,{transforms:n})},bi}function requireValidate$1(){if(Ai)return Ei;Ai=1;const e=requirePoly3(),r=requireIsA$2(),validateManifold=e=>{const r=new Map;e.polygons.forEach(({vertices:e})=>{e.forEach((t,n)=>{const o=`${`${t}`}/${`${e[(n+1)%e.length]}`}`,i=r.has(o)?r.get(o):0;r.set(o,i+1)})});const t=[];if(r.forEach((e,n)=>{const o=n.split("/").reverse().join("/");e!==r.get(o)&&t.push(n.replace("/"," -> "))}),t.length>0)throw new Error(`non-manifold edges ${t.length}\n${t.join("\n")}`)};return Ei=t=>{if(!r(t))throw new Error("invalid geom3 structure");if(t.polygons.forEach(e.validate),validateManifold(t),!t.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${t.transforms}`)}}function requireGeom3(){return Pi?$i:(Pi=1,$i={clone:requireClone$6(),create:requireCreate$8(),fromPointsConvex:requireFromPointsConvex(),fromPoints:requireFromPoints$4(),fromCompactBinary:requireFromCompactBinary$1(),invert:requireInvert(),isA:requireIsA$2(),toPoints:requireToPoints$1(),toPolygons:requireToPolygons$1(),toString:requireToString$4(),toCompactBinary:requireToCompactBinary$1(),transform:requireTransform$5(),validate:requireValidate$1()})}function requireClone$3(){if(Ti)return Mi;Ti=1;return Mi=e=>Object.assign({},e)}function requireClose(){if(Si)return Ci;Si=1;const{EPS:e}=requireConstants(),r=requireVec2(),t=requireClone$3();return Ci=n=>{if(n.isClosed)return n;const o=t(n);if(o.isClosed=!0,o.points.length>1){const t=o.points,n=t[0];let i=t[t.length-1];for(;r.distance(n,i)<e*e&&(t.pop(),1!==t.length);)i=t[t.length-1]}return o}}function requireCreate$5(){if(Vi)return Fi;Vi=1;const e=requireMat4();return Fi=r=>(void 0===r&&(r=[]),{points:r,isClosed:!1,transforms:e.create()})}function requireFromPoints$3(){if(Gi)return Ri;Gi=1;const{EPS:e}=requireConstants(),r=requireVec2(),t=requireClose(),n=requireCreate$5();return Ri=(o,i)=>{let{closed:s}=Object.assign({},{closed:!1},o),u=n();if(u.points=i.map(e=>r.clone(e)),u.points.length>1){const t=u.points[0],n=u.points[u.points.length-1];r.distance(t,n)<e*e&&(s=!0)}return!0===s&&(u=t(u)),u}}function requireToPoints(){if(zi)return Oi;zi=1;const e=function requireApplyTransforms(){if(Ni)return ki;Ni=1;const e=requireMat4(),r=requireVec2();return ki=t=>(e.isIdentity(t.transforms)||(t.points=t.points.map(e=>r.transform(r.create(),e,t.transforms)),t.transforms=e.create()),t)}();return Oi=r=>e(r).points}function requireAppendArc(){if(Bi)return Ii;Bi=1;const{TAU:e}=requireConstants(),r=requireVec2(),t=requireFromPoints$3(),n=requireToPoints();return Ii=(o,i)=>{let{endpoint:s,radius:u,xaxisrotation:a,clockwise:c,large:l,segments:f}=Object.assign({},{radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16},o);if(!Array.isArray(s))throw new Error("endpoint must be an array of X and Y values");if(s.length<2)throw new Error("endpoint must contain X and Y values");if(s=r.clone(s),!Array.isArray(u))throw new Error("radius must be an array of X and Y values");if(u.length<2)throw new Error("radius must contain X and Y values");if(f<4)throw new Error("segments must be four or more");const h=1e5;if(i.isClosed)throw new Error("the given path cannot be closed");const g=n(i);if(g.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let d=u[0],m=u[1];const q=g[g.length-1];d=Math.round(d*h)/h,m=Math.round(m*h)/h,s=r.fromValues(Math.round(s[0]*h)/h,Math.round(s[1]*h)/h);const p=!c;let y=[];if(0===d||0===m)y.push(s);else{d=Math.abs(d),m=Math.abs(m);const t=a,n=Math.cos(t),i=Math.sin(t),u=r.subtract(r.create(),q,s);r.scale(u,u,.5);const c=Math.round((n*u[0]+i*u[1])*h)/h,g=Math.round((-i*u[0]+n*u[1])*h)/h,v=r.fromValues(c,g),w=v[0]*v[0]/(d*d)+v[1]*v[1]/(m*m);if(w>1){const e=Math.sqrt(w);d*=e,m*=e,d=Math.round(d*h)/h,m=Math.round(m*h)/h}let b=Math.sqrt((d*d*m*m-d*d*v[1]*v[1]-m*m*v[0]*v[0])/(d*d*v[1]*v[1]+m*m*v[0]*v[0]));p===l&&(b=-b);const x=r.fromValues(d*v[1]/m,-m*v[0]/d);r.scale(x,x,b);let E=r.fromValues(n*x[0]-i*x[1],i*x[0]+n*x[1]);E=r.add(E,E,r.scale(r.create(),r.add(r.create(),q,s),.5));const A=r.fromValues((v[0]-x[0])/d,(v[1]-x[1])/m),$=r.fromValues((-v[0]-x[0])/d,(-v[1]-x[1])/m),P=r.angleRadians(A);let M=r.angleRadians($)-P;M%=e,!p&&M>0?M-=e:p&&M<0&&(M+=e);let T=Math.ceil(Math.abs(M)/e*f)+1;T<1&&(T=1);for(let e=1;e<T;e++){const t=P+e/T*M,o=Math.cos(t),s=Math.sin(t),u=r.fromValues(n*d*o-i*m*s,i*d*o+n*m*s);r.add(u,u,E),y.push(u)}T&&y.push(o.endpoint)}y=g.concat(y);return t({},y)}}function requireConcat(){if(ji)return Di;ji=1;const e=requireFromPoints$3(),r=requireToPoints(),{equals:t}=requireVec2();return Di=(...n)=>{let o=!1,i=[];return n.forEach((e,n)=>{const s=r(e).slice();if(i.length>0&&s.length>0&&t(s[0],i[i.length-1])&&s.shift(),s.length>0&&o)throw new Error(`Cannot concatenate to a closed path; check the ${n}th path`);o=e.isClosed,i=i.concat(s)}),e({closed:o},i)}}function requireAppendPoints(){if(_i)return Li;_i=1;const e=requireConcat(),r=requireCreate$5();return Li=(t,n)=>e(n,r(t))}function requireAppendBezier(){if(Xi)return Zi;Xi=1;const{TAU:e}=requireConstants(),r=requireVec2(),t=requireVec2(),n=requireAppendPoints(),o=requireToPoints();return Zi=(i,s)=>{let{controlPoints:u,segments:a}=Object.assign({},{segments:16},i);if(!Array.isArray(u))throw new Error("controlPoints must be an array of one or more points");if(u.length<1)throw new Error("controlPoints must be an array of one or more points");if(a<4)throw new Error("segments must be four or more");if(s.isClosed)throw new Error("the given geometry cannot be closed");const c=o(s);if(c.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");u=u.slice();if(null===u[0]){if(u.length<2)throw new Error("a null control point must be passed with one more control points");let e=c[c.length-2];if("lastBezierControlPoint"in s&&(e=s.lastBezierControlPoint),!Array.isArray(e))throw new Error("the given path must contain TWO or more points if given a null control point");const t=r.scale(r.create(),c[c.length-1],2);r.subtract(t,t,e),u[0]=t}u.unshift(c[c.length-1]);const l=u.length-1,f=[];let h=1;for(let e=0;e<=l;++e)e>0&&(h*=e),f.push(h);const g=[];for(let e=0;e<=l;++e){const r=f[l]/(f[e]*f[l-e]);g.push(r)}const d=r.create(),m=r.create(),q=t.create(),getPointForT=e=>{let t=1,n=Math.pow(1-e,l);const o=1!==e?1/(1-e):1,i=r.create();for(let s=0;s<=l;++s){s===l&&(n=1);const a=g[s]*t*n,c=r.scale(d,u[s],a);r.add(i,i,c),t*=e,n*=o}return i},p=[],y=[],v=l+1;for(let e=0;e<v;++e){const r=e/(v-1),t=getPointForT(r);p.push(t),y.push(r)}let w=1;const b=e/a,x=Math.sin(b);for(;w<p.length-1;){const e=r.subtract(d,p[w],p[w-1]);r.normalize(e,e);const t=r.subtract(m,p[w+1],p[w]);r.normalize(t,t);const n=r.cross(q,e,t);if(Math.abs(n[2])>x){const e=y[w-1],r=y[w+1],t=e+1*(r-e)/3,n=e+2*(r-e)/3,o=getPointForT(t),i=getPointForT(n);p.splice(w,1,o,i),y.splice(w,1,t,n),w--,w<1&&(w=1)}else++w}p.shift();const E=n(p,s);return E.lastBezierControlPoint=u[u.length-2],E}}function requireEquals$3(){if(Hi)return Ui;Hi=1;const e=requireVec2(),r=requireToPoints();return Ui=(t,n)=>{if(t.isClosed!==n.isClosed)return!1;if(t.points.length!==n.points.length)return!1;const o=r(t),i=r(n),s=o.length;let u=0;do{let r=!1;for(let t=0;t<s;t++)if(!e.equals(o[t],i[(t+u)%s])){r=!0;break}if(!1===r)return!0;if(!t.isClosed)return!1}while(++u<s);return!1}}function requireFromCompactBinary(){if(Wi)return Yi;Wi=1;const e=requireMat4(),r=requireVec2(),t=requireCreate$5();return Yi=n=>{if(2!==n[0])throw new Error("invalid compact binary data");const o=t();o.transforms=e.clone(n.slice(1,17)),o.isClosed=!!n[17];for(let e=22;e<n.length;e+=2){const t=r.fromValues(n[e],n[e+1]);o.points.push(t)}return n[18]>=0&&(o.color=[n[18],n[19],n[20],n[21]]),o}}function requireIsA$1(){if(Qi)return Ji;Qi=1;return Ji=e=>!!(e&&"object"==typeof e&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms)}function requireReverse$3(){if(es)return Ki;es=1;const e=requireClone$3();return Ki=r=>{const t=e(r);return t.points=r.points.slice().reverse(),t}}function requireToString$3(){if(ts)return rs;ts=1;const e=requireVec2(),r=requireToPoints();return rs=t=>{const n=r(t);let o="path ("+n.length+" points, "+t.isClosed+"):\n[\n";return n.forEach(r=>{o+="  "+e.toString(r)+",\n"}),o+="]\n",o}}function requireToCompactBinary(){if(os)return ns;os=1;return ns=e=>{const r=e.points,t=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const o=new Float32Array(22+2*r.length);o[0]=2,o[1]=t[0],o[2]=t[1],o[3]=t[2],o[4]=t[3],o[5]=t[4],o[6]=t[5],o[7]=t[6],o[8]=t[7],o[9]=t[8],o[10]=t[9],o[11]=t[10],o[12]=t[11],o[13]=t[12],o[14]=t[13],o[15]=t[14],o[16]=t[15],o[17]=e.isClosed?1:0,o[18]=n[0],o[19]=n[1],o[20]=n[2],o[21]=n[3];for(let e=0;e<r.length;e++){const t=2*e+22,n=r[e];o[t]=n[0],o[t+1]=n[1]}return o},ns}function requireTransform$4(){if(ss)return is;ss=1;const e=requireMat4();return is=(r,t)=>{const n=e.multiply(e.create(),r,t.transforms);return Object.assign({},t,{transforms:n})},is}function requireValidate(){if(as)return us;as=1;const e=requireVec2(),r=requireIsA$1();return us=t=>{if(!r(t))throw new Error("invalid path2 structure");if(t.points.length>1)for(let r=0;r<t.points.length;r++)if(e.equals(t.points[r],t.points[(r+1)%t.points.length]))throw new Error(`path2 duplicate points ${t.points[r]}`);if(t.points.forEach(e=>{if(!e.every(Number.isFinite))throw new Error(`path2 invalid point ${e}`)}),!t.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${t.transforms}`)}}function requirePath2(){return ls?cs:(ls=1,cs={appendArc:requireAppendArc(),appendBezier:requireAppendBezier(),appendPoints:requireAppendPoints(),clone:requireClone$3(),close:requireClose(),concat:requireConcat(),create:requireCreate$5(),equals:requireEquals$3(),fromPoints:requireFromPoints$3(),fromCompactBinary:requireFromCompactBinary(),isA:requireIsA$1(),reverse:requireReverse$3(),toPoints:requireToPoints(),toString:requireToString$3(),toCompactBinary:requireToCompactBinary(),transform:requireTransform$4(),validate:requireValidate()})}function requireColorize(){if(hs)return fs;hs=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2(),o=requirePoly3();return fs=(i,...s)=>{if(!Array.isArray(i))throw new Error("color must be an array");if(i.length<3)throw new Error("color must contain R, G and B values");if(3===i.length&&(i=[i[0],i[1],i[2],1]),0===(s=e(s)).length)throw new Error("wrong number of arguments");const u=s.map(e=>r.isA(e)?((e,t)=>{const n=r.clone(t);return n.color=e,n})(i,e):t.isA(e)?((e,r)=>{const n=t.clone(r);return n.color=e,n})(i,e):n.isA(e)?((e,r)=>{const t=n.clone(r);return t.color=e,t})(i,e):o.isA(e)?((e,r)=>{const t=o.clone(r);return t.color=e,t})(i,e):(e.color=i,e));return 1===u.length?u[0]:u}}function requireCssColors(){if(ds)return gs;ds=1;return gs={black:[0,0,0],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[1,1,1],maroon:[128/255,0,0],red:[1,0,0],purple:[128/255,0,128/255],fuchsia:[1,0,1],green:[0,128/255,0],lime:[0,1,0],olive:[128/255,128/255,0],yellow:[1,1,0],navy:[0,0,128/255],blue:[0,0,1],teal:[0,128/255,128/255],aqua:[0,1,1],aliceblue:[240/255,248/255,1],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,1,212/255],azure:[240/255,1,1],beige:[245/255,245/255,220/255],bisque:[1,228/255,196/255],blanchedalmond:[1,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,1,0],chocolate:[210/255,105/255,30/255],coral:[1,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[1,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0,1,1],darkblue:[0,0,139/255],darkcyan:[0,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0,100/255,0],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[1,140/255,0],darkorchid:[.6,50/255,.8],darkred:[139/255,0,0],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0,206/255,209/255],darkviolet:[148/255,0,211/255],deeppink:[1,20/255,147/255],deepskyblue:[0,191/255,1],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,1],firebrick:[178/255,34/255,34/255],floralwhite:[1,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,1],gold:[1,215/255,0],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,1,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,1,240/255],hotpink:[1,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0,130/255],ivory:[1,1,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[1,240/255,245/255],lawngreen:[124/255,252/255,0],lemonchiffon:[1,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,1,1],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[1,182/255,193/255],lightsalmon:[1,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,.6],lightslategrey:[119/255,136/255,.6],lightsteelblue:[176/255,196/255,222/255],lightyellow:[1,1,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[1,0,1],mediumaquamarine:[.4,205/255,170/255],mediumblue:[0,0,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0,250/255,154/255],mediumturquoise:[72/255,209/255,.8],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,1,250/255],mistyrose:[1,228/255,225/255],moccasin:[1,228/255,181/255],navajowhite:[1,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[1,165/255,0],orangered:[1,69/255,0],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[1,239/255,213/255],peachpuff:[1,218/255,185/255],peru:[205/255,133/255,63/255],pink:[1,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[1,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[1,250/255,250/255],springgreen:[0,1,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[1,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]}}function requireColorNameToRgb(){if(qs)return ms;qs=1;const e=requireCssColors();return ms=r=>e[r.toLowerCase()]}function requireHexToRgb(){if(ys)return ps;ys=1;return ps=e=>{if((e=e.replace("#","")).length<6)throw new Error("the given notation must contain 3 or more hex values");const r=parseInt(e.substring(0,2),16)/255,t=parseInt(e.substring(2,4),16)/255,n=parseInt(e.substring(4,6),16)/255;if(e.length>=8){return[r,t,n,parseInt(e.substring(6,8),16)/255]}return[r,t,n]}}function requireHueToColorComponent(){if(ws)return vs;ws=1;return vs=(e,r,t)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+6*(r-e)*t:t<.5?r:t<2/3?e+(r-e)*(2/3-t)*6:e)}function requireHslToRgb(){if(xs)return bs;xs=1;const e=requireFlatten$1(),r=requireHueToColorComponent();return bs=(...t)=>{if((t=e(t)).length<3)throw new Error("values must contain H, S and L values");const n=t[0],o=t[1],i=t[2];let s=i,u=i,a=i;if(0!==o){const e=i<.5?i*(1+o):i+o-i*o,t=2*i-e;s=r(t,e,n+1/3),u=r(t,e,n),a=r(t,e,n-1/3)}if(t.length>3){return[s,u,a,t[3]]}return[s,u,a]}}function requireHsvToRgb(){if(As)return Es;As=1;const e=requireFlatten$1();return Es=(...r)=>{if((r=e(r)).length<3)throw new Error("values must contain H, S and V values");const t=r[0],n=r[1],o=r[2];let i=0,s=0,u=0;const a=Math.floor(6*t),c=6*t-a,l=o*(1-n),f=o*(1-c*n),h=o*(1-(1-c)*n);switch(a%6){case 0:i=o,s=h,u=l;break;case 1:i=f,s=o,u=l;break;case 2:i=l,s=o,u=h;break;case 3:i=l,s=f,u=o;break;case 4:i=h,s=l,u=o;break;case 5:i=o,s=l,u=f}if(r.length>3){return[i,s,u,r[3]]}return[i,s,u]}}function requireRgbToHex(){if(Ps)return $s;Ps=1;const e=requireFlatten$1();return $s=(...r)=>{if((r=e(r)).length<3)throw new Error("values must contain R, G and B values");const t=255*r[0],n=255*r[1],o=255*r[2];let i=`#${Number(16777216+65536*t+256*n+o).toString(16).substring(1,7)}`;return r.length>3&&(i+=Number(255*r[3]).toString(16)),i}}function requireRgbToHsl(){if(Ts)return Ms;Ts=1;const e=requireFlatten$1();return Ms=(...r)=>{if((r=e(r)).length<3)throw new Error("values must contain R, G and B values");const t=r[0],n=r[1],o=r[2],i=Math.max(t,n,o),s=Math.min(t,n,o);let u,a;const c=(i+s)/2;if(i===s)u=a=0;else{const e=i-s;switch(a=c>.5?e/(2-i-s):e/(i+s),i){case t:u=(n-o)/e+(n<o?6:0);break;case n:u=(o-t)/e+2;break;case o:u=(t-n)/e+4}u/=6}if(r.length>3){return[u,a,c,r[3]]}return[u,a,c]}}function requireRgbToHsv(){if(Ss)return Cs;Ss=1;const e=requireFlatten$1();return Cs=(...r)=>{if((r=e(r)).length<3)throw new Error("values must contain R, G and B values");const t=r[0],n=r[1],o=r[2],i=Math.max(t,n,o),s=Math.min(t,n,o);let u;const a=i,c=i-s,l=0===i?0:c/i;if(i===s)u=0;else{switch(i){case t:u=(n-o)/c+(n<o?6:0);break;case n:u=(o-t)/c+2;break;case o:u=(t-n)/c+4}u/=6}if(r.length>3){return[u,l,a,r[3]]}return[u,l,a]}}function requireCreate$4(){if(Gs)return Rs;Gs=1;const getPointType=function(e){let r=null;return e.forEach(e=>{let t="";if(Number.isFinite(e))t="float_single";else{if(!Array.isArray(e))throw new Error("Bezier points must all be numbers or arrays of number.");e.forEach(e=>{if(!Number.isFinite(e))throw new Error("Bezier point values must all be numbers.")}),t="float_"+e.length}if(null==r)r=t;else if(r!==t)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")}),r},getPermutations=function(e){const r=[];for(let t=0;t<=e;t++)r.push(factorial(e)/(factorial(t)*factorial(e-t)));return r},factorial=function(e){let r=1;for(let t=2;t<=e;t++)r*=t;return r};return Rs=e=>{if(!Array.isArray(e))throw new Error("Bezier points must be a valid array/");if(e.length<2)throw new Error("Bezier points must contain at least 2 values.");const r=getPointType(e);return{points:e,pointType:r,dimensions:"float_single"===r?0:e[0].length,permutations:getPermutations(e.length-1),tangentPermutations:getPermutations(e.length-2)}}}function requireValueAt(){if(Ns)return ks;Ns=1;const bezierFunction=function(e,r,t){const n=r.length-1;let o=0;for(let i=0;i<=n;i++)o+=e.permutations[i]*Math.pow(1-t,n-i)*Math.pow(t,i)*r[i];return o};return ks=(e,r)=>{if(e<0||e>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if("float_single"===r.pointType)return bezierFunction(r,r.points,e);{const t=[];for(let n=0;n<r.dimensions;n++){const o=[];for(let e=0;e<r.points.length;e++)o.push(r.points[e][n]);t.push(bezierFunction(r,o,e))}return t}},ks}function requireTangentAt(){if(zs)return Os;zs=1;const bezierTangent=function(e,r,t){const n=r.length-1;let o=0;for(let i=0;i<n;i++){const s=n*(r[i+1]-r[i]);o+=e.tangentPermutations[i]*Math.pow(1-t,n-1-i)*Math.pow(t,i)*s}return o};return Os=(e,r)=>{if(e<0||e>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if("float_single"===r.pointType)return bezierTangent(r,r.points,e);{const t=[];for(let n=0;n<r.dimensions;n++){const o=[];for(let e=0;e<r.points.length;e++)o.push(r.points[e][n]);t.push(bezierTangent(r,o,e))}return t}},Os}function requireLengths(){if(Bs)return Is;Bs=1;const e=requireValueAt(),distanceBetween=(e,r)=>{if(Number.isFinite(e)&&Number.isFinite(r))return Math.abs(e-r);if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)throw new Error("The operands must have the same number of dimensions.");let t=0;for(let n=0;n<e.length;n++)t+=(r[n]-e[n])*(r[n]-e[n]);return Math.sqrt(t)}throw new Error("The operands must be of the same type, either number or array.")};return Is=(r,t)=>{let n=0;const o=[0];let i=e(0,t);for(let s=1;s<=r;s++){const u=e(s/r,t);n+=distanceBetween(u,i),o.push(n),i=u}return o},Is}function requireLength(){if(js)return Ds;js=1;const e=requireLengths();return Ds=(r,t)=>e(r,t)[r],Ds}function requireArcLengthToT(){if(_s)return Ls;_s=1;const e=requireLengths();return Ls=(r,t)=>{const{distance:n,segments:o}=Object.assign({},{distance:0,segments:100},r),i=e(o,t);let s=0,u=o;for(;s<=u;){const e=Math.floor(s+(u-s)/2),r=i[e]-n;if(r<0)s=e+1;else{if(!(r>0)){u=e;break}u=e-1}}const a=u;if(i[a]===n)return a/o;const c=i[a];return(a+(n-c)/(i[a+1]-c))/o},Ls}function requireArea(){if(Ws)return Ys;Ws=1;return Ys=e=>{let r=0;for(let t=0;t<e.length;t++){const n=(t+1)%e.length;r+=e[t][0]*e[n][1],r-=e[n][0]*e[t][1]}return r/2},Ys}function requireMeasureArea$1(){if(Qs)return Js;Qs=1;const e=requireArea();return Js=r=>e(r.vertices)}function requireCreate$3(){if(eu)return Ks;eu=1;return Ks=e=>((void 0===e||e.length<3)&&(e=[]),{vertices:e})}function requireFlip(){if(tu)return ru;tu=1;const e=requireCreate$3();return ru=r=>{const t=r.vertices.slice().reverse();return e(t)}}function requireArePointsInside(){if(ou)return nu;ou=1;const e=requireMeasureArea$1(),r=requireFlip(),isPointInside=(e,r)=>{const t=r.length,n=e[0],o=e[1];let i=r[t-1],s=r[0],u=i[1]>o,a=0,c=0;for(let e=t+1;--e;){const e=s[1]>o;if(u!==e){const e=i[0]>n,r=s[0]>n;(e&&r||s[0]-(s[1]-o)*(i[0]-s[0])/(i[1]-s[1])>=n)&&(a=!a)}u=e,i=s,s=r[++c]}return a};return nu=(t,n)=>{if(0===t.length)return 0;const o=n.vertices;if(o.length<3)return 0;e(n)<0&&(n=r(n));return t.reduce((e,r)=>e+isPointInside(r,o),0)===t.length?1:0}}function requirePoly2(){return su?iu:(su=1,iu={arePointsInside:requireArePointsInside(),create:requireCreate$3(),flip:requireFlip(),measureArea:requireMeasureArea$1()})}function requireGeometries(){return au?uu:(au=1,uu={geom2:requireGeom2(),geom3:requireGeom3(),path2:requirePath2(),poly2:requirePoly2(),poly3:requirePoly3()})}function requireCreate$2(){if(lu)return cu;lu=1;return cu=()=>[0,1,0]}function requireClone$2(){if(hu)return fu;hu=1;const e=requireCreate$2();return fu=r=>{const t=e();return t[0]=r[0],t[1]=r[1],t[2]=r[2],t}}function requireDirection$1(){if(du)return gu;du=1;const e=requireVec2();return gu=r=>{const t=e.normal(e.create(),r);return e.negate(t,t),t}}function requireOrigin$1(){if(qu)return mu;qu=1;const e=requireVec2();return mu=r=>e.scale(e.create(),r,r[2])}function requireClosestPoint$1(){if(yu)return pu;yu=1;const e=requireVec2(),r=requireDirection$1(),t=requireOrigin$1();return pu=(n,o)=>{const i=t(n),s=r(n),u=e.subtract(e.create(),o,i),a=e.dot(u,s);return e.scale(u,s,a),e.add(u,u,i),u}}function requireCopy$1(){if(wu)return vu;wu=1;return vu=(e,r)=>(e[0]=r[0],e[1]=r[1],e[2]=r[2],e)}function requireDistanceToPoint$1(){if(xu)return bu;xu=1;const e=requireVec2();return bu=(r,t)=>{let n=e.dot(t,r);return n=Math.abs(n-r[2]),n}}function requireEquals$2(){if(Au)return Eu;Au=1;return Eu=(e,r)=>e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2],Eu}function requireFromPoints$2(){if(Pu)return $u;Pu=1;const e=requireVec2();return $u=(r,t,n)=>{const o=e.subtract(e.create(),n,t);e.normal(o,o),e.normalize(o,o);const i=e.dot(t,o);return r[0]=o[0],r[1]=o[1],r[2]=i,r}}function requireFromValues(){if(Tu)return Mu;Tu=1;const e=requireCreate$2();return Mu=(r,t,n)=>{const o=e();return o[0]=r,o[1]=t,o[2]=n,o}}function requireAboutEqualNormals(){if(Su)return Cu;Su=1;const{NEPS:e}=requireConstants();return Cu=(r,t)=>Math.abs(r[0]-t[0])<=e&&Math.abs(r[1]-t[1])<=e&&Math.abs(r[2]-t[2])<=e}function requireInterpolateBetween2DPointsForY(){if(Vu)return Fu;Vu=1;return Fu=(e,r,t)=>{let n,o=t-e[1],i=r[1]-e[1];i<0&&(o=-o,i=-i),n=o<=0?0:o>=i?1:i<1e-10?.5:o/i;return e[0]+n*(r[0]-e[0])}}function requireIntersect$1(){if(Gu)return Ru;Gu=1;return Ru=(e,r,t,n)=>{if(e[0]===r[0]&&e[1]===r[1]||t[0]===n[0]&&t[1]===n[1])return;const o=(n[1]-t[1])*(r[0]-e[0])-(n[0]-t[0])*(r[1]-e[1]);if(Math.abs(o)<Number.MIN_VALUE)return;const i=((n[0]-t[0])*(e[1]-t[1])-(n[1]-t[1])*(e[0]-t[0]))/o,s=((r[0]-e[0])*(e[1]-t[1])-(r[1]-e[1])*(e[0]-t[0]))/o;if(i<0||i>1||s<0||s>1)return;return[e[0]+i*(r[0]-e[0]),e[1]+i*(r[1]-e[1])]}}function requireSolve2Linear(){if(Nu)return ku;Nu=1;return ku=(e,r,t,n,o,i)=>{const s=1/(e*n-r*t);let u=o*n-r*i,a=-o*t+e*i;return u*=s,a*=s,[u,a]}}function requireUtils$1(){return zu?Ou:(zu=1,Ou={aboutEqualNormals:requireAboutEqualNormals(),area:requireArea(),cos:requireTrigonometry().cos,interpolateBetween2DPointsForY:requireInterpolateBetween2DPointsForY(),intersect:requireIntersect$1(),sin:requireTrigonometry().sin,solve2Linear:requireSolve2Linear()})}function requireIntersectPointOfLines(){if(Bu)return Iu;Bu=1;const e=requireVec2(),{solve2Linear:r}=requireUtils$1();return Iu=(t,n)=>{const o=r(t[0],t[1],n[0],n[1],t[2],n[2]);return e.clone(o)},Iu}function requireReverse$2(){if(ju)return Du;ju=1;const e=requireVec2(),r=requireCopy$1(),t=requireFromValues();return Du=(n,o)=>{const i=e.negate(e.create(),o),s=-o[2];return r(n,t(i[0],i[1],s))}}function requireToString$2(){if(_u)return Lu;_u=1;return Lu=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`}function requireTransform$3(){if(Xu)return Zu;Xu=1;const e=requireVec2(),r=requireFromPoints$2(),t=requireOrigin$1(),n=requireDirection$1();return Zu=(o,i,s)=>{const u=t(i),a=n(i);return e.transform(u,u,s),e.transform(a,a,s),r(o,u,a)}}function requireXAtY(){if(Hu)return Uu;Hu=1;const e=requireOrigin$1();return Uu=(r,t)=>{let n=(r[2]-r[1]*t)/r[0];if(Number.isNaN(n)){n=e(r)[0]}return n}}function requireLine2(){return Wu?Yu:(Wu=1,Yu={clone:requireClone$2(),closestPoint:requireClosestPoint$1(),copy:requireCopy$1(),create:requireCreate$2(),direction:requireDirection$1(),distanceToPoint:requireDistanceToPoint$1(),equals:requireEquals$2(),fromPoints:requireFromPoints$2(),fromValues:requireFromValues(),intersectPointOfLines:requireIntersectPointOfLines(),origin:requireOrigin$1(),reverse:requireReverse$2(),toString:requireToString$2(),transform:requireTransform$3(),xAtY:requireXAtY()})}function requireCreate$1(){if(Qu)return Ju;Qu=1;const e=requireVec3();return Ju=()=>[e.fromValues(0,0,0),e.fromValues(0,0,1)]}function requireClone$1(){if(ea)return Ku;ea=1;const e=requireVec3(),r=requireCreate$1();return Ku=t=>{const n=r();return e.copy(n[0],t[0]),e.copy(n[1],t[1]),n}}function requireClosestPoint(){if(ta)return ra;ta=1;const e=requireVec3();return ra=(r,t)=>{const n=r[0],o=r[1],i=e.dot(e.subtract(e.create(),t,n),o)/e.dot(o,o),s=e.scale(e.create(),o,i);return e.add(s,s,n),s}}function requireCopy(){if(oa)return na;oa=1;const e=requireVec3();return na=(r,t)=>(e.copy(r[0],t[0]),e.copy(r[1],t[1]),r)}function requireDirection(){if(sa)return ia;sa=1;return ia=e=>e[1]}function requireDistanceToPoint(){if(aa)return ua;aa=1;const e=requireVec3(),r=requireClosestPoint();return ua=(t,n)=>{const o=r(t,n),i=e.subtract(e.create(),n,o);return e.length(i)}}function requireEquals$1(){if(la)return ca;la=1;const e=requireVec3();return ca=(r,t)=>!!e.equals(r[1],t[1])&&!!e.equals(r[0],t[0]),ca}function requireFromPointAndDirection(){if(ha)return fa;ha=1;const e=requireVec3();return fa=(r,t,n)=>{const o=e.normalize(e.create(),n);return e.copy(r[0],t),e.copy(r[1],o),r}}function requireFromPlanes(){if(da)return ga;da=1;const e=requireVec3(),{solve2Linear:r}=requireUtils$1(),{EPS:t}=requireConstants(),n=requireFromPointAndDirection();return ga=(o,i,s)=>{let u=e.cross(e.create(),i,s),a=e.length(u);if(a<t)throw new Error("parallel planes do not intersect");a=1/a,u=e.scale(u,u,a);const c=Math.abs(u[0]),l=Math.abs(u[1]),f=Math.abs(u[2]);let h,g;return c>=l&&c>=f?(g=r(i[1],i[2],s[1],s[2],i[3],s[3]),h=e.fromValues(0,g[0],g[1])):l>=c&&l>=f?(g=r(i[0],i[2],s[0],s[2],i[3],s[3]),h=e.fromValues(g[0],0,g[1])):(g=r(i[0],i[1],s[0],s[1],i[3],s[3]),h=e.fromValues(g[0],g[1],0)),n(o,h,u)}}function requireFromPoints$1(){if(qa)return ma;qa=1;const e=requireVec3(),r=requireFromPointAndDirection();return ma=(t,n,o)=>{const i=e.subtract(e.create(),o,n);return r(t,n,i)}}function requireIntersectPointOfLineAndPlane(){if(ya)return pa;ya=1;const e=requireVec3();return pa=(r,t)=>{const n=t,o=t[3],i=r[0],s=r[1],u=(o-e.dot(n,i))/e.dot(n,s);return e.add(e.create(),i,e.scale(e.create(),s,u))},pa}function requireOrigin(){if(wa)return va;wa=1;return va=e=>e[0]}function requireReverse$1(){if(xa)return ba;xa=1;const e=requireVec3(),r=requireFromPointAndDirection();return ba=(t,n)=>{const o=e.clone(n[0]),i=e.negate(e.create(),n[1]);return r(t,o,i)}}function requireToString$1(){if(Aa)return Ea;Aa=1;return Ea=e=>{const r=e[0],t=e[1];return`line3: point: (${r[0].toFixed(7)}, ${r[1].toFixed(7)}, ${r[2].toFixed(7)}) direction: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)})`}}function requireTransform$2(){if(Pa)return $a;Pa=1;const e=requireVec3(),r=requireFromPointAndDirection();return $a=(t,n,o)=>{const i=n[0],s=n[1],u=e.add(e.create(),i,s),a=e.transform(e.create(),i,o),c=e.transform(u,u,o),l=e.subtract(c,c,a);return r(t,a,l)}}function requireMeasureArea(){if(Va)return Fa;Va=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2(),o=requirePoly3(),i=new WeakMap;return Fa=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");const u=s.map(e=>n.isA(e)?0:r.isA(e)?(e=>{let t=i.get(e);return t||(t=r.toSides(e).reduce((e,r)=>e+(r[0][0]*r[1][1]-r[0][1]*r[1][0]),0),t*=.5,i.set(e,t),t)})(e):t.isA(e)?(e=>{let r=i.get(e);return r||(r=t.toPolygons(e).reduce((e,r)=>e+o.measureArea(r),0),i.set(e,r),r)})(e):0);return 1===u.length?u[0]:u},Fa}function requireMeasureAggregateArea(){if(Ga)return Ra;Ga=1;const e=requireFlatten$1(),r=requireMeasureArea();return Ra=(...t)=>{if(0===(t=e(t)).length)throw new Error("measureAggregateArea: no geometries supplied");const n=r(t);if(1===t.length)return n;return n.reduce((e,r)=>e+r,0)},Ra}function requireMeasureBoundingBox(){if(Na)return ka;Na=1;const e=requireFlatten$1(),r=requireVec2(),t=requireVec3(),n=requireGeom2(),o=requireGeom3(),i=requirePath2(),s=requirePoly3(),u=new WeakMap;return ka=(...a)=>{if(0===(a=e(a)).length)throw new Error("wrong number of arguments");const c=a.map(e=>i.isA(e)?(e=>{let t=u.get(e);if(t)return t;const n=i.toPoints(e);let o;o=0===n.length?r.create():r.clone(n[0]);let s=r.clone(o);return n.forEach(e=>{r.min(o,o,e),r.max(s,s,e)}),o=[o[0],o[1],0],s=[s[0],s[1],0],t=[o,s],u.set(e,t),t})(e):n.isA(e)?(e=>{let t=u.get(e);if(t)return t;const o=n.toPoints(e);let i;i=0===o.length?r.create():r.clone(o[0]);let s=r.clone(i);return o.forEach(e=>{r.min(i,i,e),r.max(s,s,e)}),i=[i[0],i[1],0],s=[s[0],s[1],0],t=[i,s],u.set(e,t),t})(e):o.isA(e)?(e=>{let r=u.get(e);if(r)return r;const n=o.toPolygons(e);let i=t.create();if(n.length>0){const e=s.toPoints(n[0]);t.copy(i,e[0])}let a=t.clone(i);return n.forEach(e=>{s.toPoints(e).forEach(e=>{t.min(i,i,e),t.max(a,a,e)})}),i=[i[0],i[1],i[2]],a=[a[0],a[1],a[2]],r=[i,a],u.set(e,r),r})(e):[[0,0,0],[0,0,0]]);return 1===c.length?c[0]:c},ka}function requireMeasureAggregateBoundingBox(){if(za)return Oa;za=1;const e=requireFlatten$1(),r=requireMin$1(),t=requireMax$1(),n=requireMeasureBoundingBox();return Oa=(...o)=>{if(0===(o=e(o)).length)throw new Error("measureAggregateBoundingBox: no geometries supplied");const i=n(o);if(1===o.length)return i;const s=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return i.reduce((e,n)=>e=[r(e[0],e[0],n[0]),t(e[1],e[1],n[1])],s)},Oa}function requireCalculateEpsilonFromBounds(){if(Ba)return Ia;Ba=1;const{EPS:e}=requireConstants();return Ia=(r,t)=>{let n=0;for(let e=0;e<t;e++)n+=r[1][e]-r[0][e];return e*n/t}}function requireMeasureAggregateEpsilon(){if(ja)return Da;ja=1;const e=requireFlatten$1(),r=requireMeasureAggregateBoundingBox(),t=requireCalculateEpsilonFromBounds(),{geom2:n,geom3:o,path2:i}=requireGeometries();return Da=(...s)=>{if(0===(s=e(s)).length)throw new Error("measureAggregateEpsilon: no geometries supplied");const u=r(s);let a=0;return a=s.reduce((e,r)=>i.isA(r)||n.isA(r)?Math.max(e,2):o.isA(r)?Math.max(e,3):0,a),t(u,a)},Da}function requireMeasureVolume(){if(_a)return La;_a=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2(),o=requirePoly3(),i=new WeakMap;return La=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");const u=s.map(e=>n.isA(e)||r.isA(e)?0:t.isA(e)?(e=>{let r=i.get(e);return r||(r=t.toPolygons(e).reduce((e,r)=>e+o.measureSignedVolume(r),0),i.set(e,r),r)})(e):0);return 1===u.length?u[0]:u},La}function requireMeasureAggregateVolume(){if(Xa)return Za;Xa=1;const e=requireFlatten$1(),r=requireMeasureVolume();return Za=(...t)=>{if(0===(t=e(t)).length)throw new Error("measureAggregateVolume: no geometries supplied");const n=r(t);if(1===t.length)return n;return n.reduce((e,r)=>e+r,0)},Za}function requireMeasureBoundingSphere(){if(Ha)return Ua;Ha=1;const e=requireFlatten$1(),r=requireVec2(),t=requireVec3(),n=requireGeom2(),o=requireGeom3(),i=requirePath2(),s=requirePoly3(),u=new WeakMap;return Ua=(...a)=>{const c=(a=e(a)).map(e=>i.isA(e)?(e=>{let n=u.get(e);if(void 0!==n)return n;const o=t.create();let s=0;const a=i.toPoints(e);if(a.length>0){let e=0;const n=t.create();a.forEach(r=>{t.add(o,o,t.fromVec2(n,r,0)),e++}),t.scale(o,o,1/e),a.forEach(e=>{s=Math.max(s,r.squaredDistance(o,e))}),s=Math.sqrt(s)}return n=[o,s],u.set(e,n),n})(e):n.isA(e)?(e=>{let o=u.get(e);if(void 0!==o)return o;const i=t.create();let s=0;const a=n.toSides(e);if(a.length>0){let e=0;const n=t.create();a.forEach(r=>{t.add(i,i,t.fromVec2(n,r[0],0)),e++}),t.scale(i,i,1/e),a.forEach(e=>{s=Math.max(s,r.squaredDistance(i,e[0]))}),s=Math.sqrt(s)}return o=[i,s],u.set(e,o),o})(e):o.isA(e)?(e=>{let r=u.get(e);if(void 0!==r)return r;const n=t.create();let i=0;const a=o.toPolygons(e);if(a.length>0){let e=0;a.forEach(r=>{s.toPoints(r).forEach(r=>{t.add(n,n,r),e++})}),t.scale(n,n,1/e),a.forEach(e=>{s.toPoints(e).forEach(e=>{i=Math.max(i,t.squaredDistance(n,e))})}),i=Math.sqrt(i)}return r=[n,i],u.set(e,r),r})(e):[[0,0,0],0]);return 1===c.length?c[0]:c},Ua}function requireMeasureCenter(){if(Wa)return Ya;Wa=1;const e=requireFlatten$1(),r=requireMeasureBoundingBox();return Ya=(...t)=>{const n=(t=e(t)).map(e=>{const t=r(e);return[t[0][0]+(t[1][0]-t[0][0])/2,t[0][1]+(t[1][1]-t[0][1])/2,t[0][2]+(t[1][2]-t[0][2])/2]});return 1===n.length?n[0]:n},Ya}function requireMeasureCenterOfMass(){if(Qa)return Ja;Qa=1;const e=requireFlatten$1(),r=requireVec3(),t=requireGeom2(),n=requireGeom3(),o=new WeakMap;return Ja=(...i)=>{const s=(i=e(i)).map(e=>t.isA(e)?(e=>{let n=o.get(e);if(void 0!==n)return n;const i=t.toSides(e);let s=0,u=0,a=0;if(i.length>0){for(let e=0;e<i.length;e++){const r=i[e][0],t=i[e][1],n=r[0]*t[1]-r[1]*t[0];s+=n,u+=(r[0]+t[0])*n,a+=(r[1]+t[1])*n}s/=2;const e=1/(6*s);u*=e,a*=e}return n=r.fromValues(u,a,0),o.set(e,n),n})(e):n.isA(e)?(e=>{let t=o.get(e);if(void 0!==t)return t;t=r.create();const i=n.toPolygons(e);if(0===i.length)return t;let s=0;const u=r.create();return i.forEach(e=>{const n=e.vertices;for(let e=0;e<n.length-2;e++){r.cross(u,n[e+1],n[e+2]);const o=r.dot(n[0],u)/6;s+=o,r.add(u,n[0],n[e+1]),r.add(u,u,n[e+2]);const i=r.scale(u,u,1/4*o);r.add(t,t,i)}}),r.scale(t,t,1/s),o.set(e,t),t})(e):[0,0,0]);return 1===s.length?s[0]:s},Ja}function requireMeasureDimensions(){if(ec)return Ka;ec=1;const e=requireFlatten$1(),r=requireMeasureBoundingBox();return Ka=(...t)=>{const n=(t=e(t)).map(e=>{const t=r(e);return[t[1][0]-t[0][0],t[1][1]-t[0][1],t[1][2]-t[0][2]]});return 1===n.length?n[0]:n},Ka}function requireMeasureEpsilon(){if(tc)return rc;tc=1;const e=requireFlatten$1(),{geom2:r,geom3:t,path2:n}=requireGeometries(),o=requireCalculateEpsilonFromBounds(),i=requireMeasureBoundingBox();return rc=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");const u=s.map(e=>n.isA(e)||r.isA(e)?(e=>o(i(e),2))(e):t.isA(e)?(e=>o(i(e),3))(e):0);return 1===u.length?u[0]:u},rc}function requireCommonChecks(){if(sc)return ic;sc=1;return ic={isNumberArray:(e,r)=>!!(Array.isArray(e)&&e.length>=r)&&e.every(e=>Number.isFinite(e)),isGT:(e,r)=>Number.isFinite(e)&&e>r,isGTE:(e,r)=>Number.isFinite(e)&&e>=r}}function requireArc(){if(ac)return uc;ac=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec2(),n=requirePath2(),{isGT:o,isGTE:i,isNumberArray:s}=requireCommonChecks();return uc=u=>{const a={center:[0,0],radius:1,startAngle:0,endAngle:r,makeTangent:!1,segments:32};let{center:c,radius:l,startAngle:f,endAngle:h,makeTangent:g,segments:d}=Object.assign({},a,u);if(!s(c,2))throw new Error("center must be an array of X and Y values");if(!o(l,0))throw new Error("radius must be greater than zero");if(!i(f,0))throw new Error("startAngle must be positive");if(!i(h,0))throw new Error("endAngle must be positive");if(!i(d,4))throw new Error("segments must be four or more");f%=r,h%=r;let m=r;f<h&&(m=h-f),f>h&&(m=h+(r-f));const q=Math.acos((l*l+l*l-e*e)/(2*l*l)),p=t.clone(c);let y;const v=[];if(m<q)y=t.fromAngleRadians(t.create(),f),t.scale(y,y,l),t.add(y,y,p),v.push(y);else{const e=Math.max(1,Math.floor(d*(m/r)))+1;let n=.5*e/m;n>.25&&(n=.25);const o=g?e+2:e;for(let r=0;r<=o;r++){let o=r;g&&(o=(r-1)*(e-2*n)/e+n,o<0&&(o=0),o>e&&(o=e));const i=f+o*(m/e);y=t.fromAngleRadians(t.create(),i),t.scale(y,y,l),t.add(y,y,p),v.push(y)}}return n.fromPoints({closed:!1},v)},uc}function requireEllipse(){if(lc)return cc;lc=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec2(),n=requireGeom2(),{sin:o,cos:i}=requireTrigonometry(),{isGTE:s,isNumberArray:u}=requireCommonChecks();return cc=a=>{const c={center:[0,0],radius:[1,1],startAngle:0,endAngle:r,segments:32};let{center:l,radius:f,startAngle:h,endAngle:g,segments:d}=Object.assign({},c,a);if(!u(l,2))throw new Error("center must be an array of X and Y values");if(!u(f,2))throw new Error("radius must be an array of X and Y values");if(!f.every(e=>e>=0))throw new Error("radius values must be positive");if(!s(h,0))throw new Error("startAngle must be positive");if(!s(g,0))throw new Error("endAngle must be positive");if(!s(d,3))throw new Error("segments must be three or more");if(0===f[0]||0===f[1])return n.create();h%=r,g%=r;let m=r;h<g&&(m=g-h),h>g&&(m=g+(r-h));const q=Math.min(f[0],f[1]);if(m<Math.acos((q*q+q*q-e*e)/(2*q*q)))throw new Error("startAngle and endAngle do not define a significant rotation");d=Math.floor(d*(m/r));const p=t.clone(l),y=m/d,v=[];d=m<r?d+1:d;for(let e=0;e<d;e++){const r=y*e+h,n=t.fromValues(f[0]*i(r),f[1]*o(r));t.add(n,p,n),v.push(n)}return m<r&&v.push(p),n.fromPoints(v)},cc}function requireCircle(){if(hc)return fc;hc=1;const{TAU:e}=requireConstants(),r=requireEllipse(),{isGTE:t}=requireCommonChecks();return fc=n=>{const o={center:[0,0],radius:1,startAngle:0,endAngle:e,segments:32};let{center:i,radius:s,startAngle:u,endAngle:a,segments:c}=Object.assign({},o,n);if(!t(s,0))throw new Error("radius must be positive");return s=[s,s],r({center:i,radius:s,startAngle:u,endAngle:a,segments:c})}}function requireCuboid(){if(dc)return gc;dc=1;const e=requireGeom3(),r=requirePoly3(),{isNumberArray:t}=requireCommonChecks();return gc=n=>{const{center:o,size:i}=Object.assign({},{center:[0,0,0],size:[2,2,2]},n);if(!t(o,3))throw new Error("center must be an array of X, Y and Z values");if(!t(i,3))throw new Error("size must be an array of width, depth and height values");if(!i.every(e=>e>=0))throw new Error("size values must be positive");if(0===i[0]||0===i[1]||0===i[2])return e.create();return e.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(e=>{const t=e[0].map(e=>[o[0]+i[0]/2*(2*!!(1&e)-1),o[1]+i[1]/2*(2*!!(2&e)-1),o[2]+i[2]/2*(2*!!(4&e)-1)]);return r.create(t)}))}}function requireCube(){if(qc)return mc;qc=1;const e=requireCuboid(),{isGTE:r}=requireCommonChecks();return mc=t=>{let{center:n,size:o}=Object.assign({},{center:[0,0,0],size:2},t);if(!r(o,0))throw new Error("size must be positive");return o=[o,o,o],e({center:n,size:o})}}function requireCylinderElliptic(){if(yc)return pc;yc=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec3(),n=requireGeom3(),o=requirePoly3(),{sin:i,cos:s}=requireTrigonometry(),{isGT:u,isGTE:a,isNumberArray:c}=requireCommonChecks();return pc=l=>{const f={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:r,segments:32};let{center:h,height:g,startRadius:d,startAngle:m,endRadius:q,endAngle:p,segments:y}=Object.assign({},f,l);if(!c(h,3))throw new Error("center must be an array of X, Y and Z values");if(!u(g,0))throw new Error("height must be greater then zero");if(!c(d,2))throw new Error("startRadius must be an array of X and Y values");if(!d.every(e=>e>=0))throw new Error("startRadius values must be positive");if(!c(q,2))throw new Error("endRadius must be an array of X and Y values");if(!q.every(e=>e>=0))throw new Error("endRadius values must be positive");if(q.every(e=>0===e)&&d.every(e=>0===e))throw new Error("at least one radius must be positive");if(!a(m,0))throw new Error("startAngle must be positive");if(!a(p,0))throw new Error("endAngle must be positive");if(!a(y,4))throw new Error("segments must be four or more");m%=r,p%=r;let v=r;m<p&&(v=p-m),m>p&&(v=p+(r-m));const w=Math.min(d[0],d[1],q[0],q[1]),b=Math.acos((w*w+w*w-e*e)/(2*w*w));if(v<b)throw new Error("startAngle and endAngle do not define a significant rotation");const x=Math.floor(y*(v/r)),E=t.fromValues(0,0,-g/2),A=t.fromValues(0,0,g/2),$=t.subtract(t.create(),A,E),P=t.fromValues(1,0,0),M=t.fromValues(0,1,0),T=t.create(),C=t.create(),S=t.create(),point=(e,r,n)=>{const o=r*v+m;return t.scale(T,P,n[0]*s(o)),t.scale(C,M,n[1]*i(o)),t.add(T,T,C),t.scale(S,$,e),t.add(S,S,E),t.add(t.create(),T,S)},fromPoints=(...e)=>{const r=e.map(e=>t.add(t.create(),e,h));return o.create(r)},F=[];for(let e=0;e<x;e++){const t=e/x;let n=(e+1)/x;v===r&&e===x-1&&(n=0),q[0]===d[0]&&q[1]===d[1]?(F.push(fromPoints(E,point(0,n,q),point(0,t,q))),F.push(fromPoints(point(0,n,q),point(1,n,q),point(1,t,q),point(0,t,q))),F.push(fromPoints(A,point(1,t,q),point(1,n,q)))):(d[0]>0&&d[1]>0&&F.push(fromPoints(E,point(0,n,d),point(0,t,d))),(d[0]>0||d[1]>0)&&F.push(fromPoints(point(0,t,d),point(0,n,d),point(1,t,q))),q[0]>0&&q[1]>0&&F.push(fromPoints(A,point(1,t,q),point(1,n,q))),(q[0]>0||q[1]>0)&&F.push(fromPoints(point(1,t,q),point(0,n,d),point(1,n,q))))}v<r&&(F.push(fromPoints(E,point(0,0,d),A)),F.push(fromPoints(point(0,0,d),point(1,0,q),A)),F.push(fromPoints(E,A,point(0,1,d))),F.push(fromPoints(point(0,1,d),A,point(1,1,q))));return n.create(F)},pc}function requireCylinder(){if(wc)return vc;wc=1;const e=requireGeom3(),r=requireCylinderElliptic(),{isGTE:t}=requireCommonChecks();return vc=n=>{const{center:o,height:i,radius:s,segments:u}=Object.assign({},{center:[0,0,0],height:2,radius:1,segments:32},n);if(!t(s,0))throw new Error("radius must be positive");if(0===i||0===s)return e.create();return r({center:o,height:i,startRadius:[s,s],endRadius:[s,s],segments:u})}}function requireEllipsoid(){if(xc)return bc;xc=1;const{TAU:e}=requireConstants(),r=requireVec3(),t=requireGeom3(),n=requirePoly3(),{sin:o,cos:i}=requireTrigonometry(),{isGTE:s,isNumberArray:u}=requireCommonChecks();return bc=a=>{const{center:c,radius:l,segments:f,axes:h}=Object.assign({},{center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},a);if(!u(c,3))throw new Error("center must be an array of X, Y and Z values");if(!u(l,3))throw new Error("radius must be an array of X, Y and Z values");if(!l.every(e=>e>=0))throw new Error("radius values must be positive");if(!s(f,4))throw new Error("segments must be four or more");if(0===l[0]||0===l[1]||0===l[2])return t.create();const g=r.scale(r.create(),r.normalize(r.create(),h[0]),l[0]),d=r.scale(r.create(),r.normalize(r.create(),h[1]),l[1]),m=r.scale(r.create(),r.normalize(r.create(),h[2]),l[2]),q=Math.round(f/4);let p;const y=[],v=r.create(),w=r.create();for(let t=0;t<=f;t++){const s=e*t/f,u=r.add(r.create(),r.scale(v,g,i(s)),r.scale(w,d,o(s)));if(t>0){let t,s;for(let a=0;a<=q;a++){const l=e/4*a/q,f=i(l),h=o(l);if(a>0){let e,o=[];e=r.subtract(r.create(),r.scale(v,p,t),r.scale(w,m,s)),o.push(r.add(e,e,c)),e=r.subtract(r.create(),r.scale(v,u,t),r.scale(w,m,s)),o.push(r.add(e,e,c)),a<q&&(e=r.subtract(r.create(),r.scale(v,u,f),r.scale(w,m,h)),o.push(r.add(e,e,c))),e=r.subtract(r.create(),r.scale(v,p,f),r.scale(w,m,h)),o.push(r.add(e,e,c)),y.push(n.create(o)),o=[],e=r.add(r.create(),r.scale(v,p,t),r.scale(w,m,s)),o.push(r.add(r.create(),c,e)),e=r.add(e,r.scale(v,u,t),r.scale(w,m,s)),o.push(r.add(r.create(),c,e)),a<q&&(e=r.add(e,r.scale(v,u,f),r.scale(w,m,h)),o.push(r.add(r.create(),c,e))),e=r.add(e,r.scale(v,p,f),r.scale(w,m,h)),o.push(r.add(r.create(),c,e)),o.reverse(),y.push(n.create(o))}t=f,s=h}}p=u}return t.create(y)},bc}function requirePolyhedron(){if(Ac)return Ec;Ac=1;const e=requireGeom3(),r=requirePoly3(),{isNumberArray:t}=requireCommonChecks();return Ec=n=>{const o={points:[],faces:[],colors:void 0,orientation:"outward"},{points:i,faces:s,colors:u,orientation:a}=Object.assign({},o,n);if(!Array.isArray(i)||!Array.isArray(s))throw new Error("points and faces must be arrays");if(i.length<3)throw new Error("three or more points are required");if(s.length<1)throw new Error("one or more faces are required");if(u){if(!Array.isArray(u))throw new Error("colors must be an array");if(u.length!==s.length)throw new Error("faces and colors must have the same length")}i.forEach((e,r)=>{if(!t(e,3))throw new Error(`point ${r} must be an array of X, Y, Z values`)}),s.forEach((e,r)=>{if(e.length<3)throw new Error(`face ${r} must contain 3 or more indexes`);if(!t(e,e.length))throw new Error(`face ${r} must be an array of numbers`)}),"outward"!==a&&s.forEach(e=>e.reverse());const c=s.map((e,t)=>{const n=r.create(e.map(e=>i[e]));return u&&u[t]&&(n.color=u[t]),n});return e.create(c)},Ec}function requireGeodesicSphere(){if(Pc)return $c;Pc=1;const e=requireMat4(),r=requireVec3(),t=requireGeom3(),n=requirePolyhedron(),{isGTE:o}=requireCommonChecks();return $c=i=>{let{radius:s,frequency:u}=Object.assign({},{radius:1,frequency:6},i);if(!o(s,0))throw new Error("radius must be positive");if(!o(u,6))throw new Error("frequency must be six or more");if(0===s)return t.create();u=Math.floor(u/6);const a=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],c=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],geodesicSubDivide=(e,t,n)=>{const o=e[0],i=e[1],s=e[2];let u=n;const a=[],c=[];for(let e=0;e<t;e++)for(let n=0;n<t-e;n++){const l=e/t,f=(e+1)/t,h=n/(t-e),g=(n+1)/(t-e),d=t-e-1?n/(t-e-1):1,m=[];m[0]=mix3(mix3(o,i,h),s,l),m[1]=mix3(mix3(o,i,g),s,l),m[2]=mix3(mix3(o,i,d),s,f);for(let e=0;e<3;e++){const t=r.length(m[e]);for(let r=0;r<3;r++)m[e][r]/=t}if(a.push(m[0],m[1],m[2]),c.push([u,u+1,u+2]),u+=3,n<t-e-1){const h=t-e-1?(n+1)/(t-e-1):1;m[0]=mix3(mix3(o,i,g),s,l),m[1]=mix3(mix3(o,i,h),s,f),m[2]=mix3(mix3(o,i,d),s,f);for(let e=0;e<3;e++){const t=r.length(m[e]);for(let r=0;r<3;r++)m[e][r]/=t}a.push(m[0],m[1],m[2]),c.push([u,u+1,u+2]),u+=3}}return{points:a,triangles:c,offset:u}},mix3=(e,r,t)=>{const n=1-t,o=[];for(let i=0;i<3;i++)o[i]=e[i]*n+r[i]*t;return o};let l=[],f=[],h=0;for(let e=0;e<c.length;e++){const r=geodesicSubDivide([a[c[e][0]],a[c[e][1]],a[c[e][2]]],u,h);l=l.concat(r.points),f=f.concat(r.triangles),h=r.offset}let g=n({points:l,faces:f,orientation:"inward"});return 1!==s&&(g=t.transform(e.fromScaling(e.create(),[s,s,s]),g)),g}}function requireLine(){if(Tc)return Mc;Tc=1;const e=requirePath2();return Mc=r=>{if(!Array.isArray(r))throw new Error("points must be an array");return e.fromPoints({},r)}}function requirePolygon(){if(Sc)return Cc;Sc=1;const e=requireGeom2();return Cc=r=>{const{points:t,paths:n,orientation:o}=Object.assign({},{points:[],paths:[],orientation:"counterclockwise"},r);if(!Array.isArray(t)||!Array.isArray(n))throw new Error("points and paths must be arrays");let i=t;Array.isArray(t[0])&&(Array.isArray(t[0][0])||(i=[t])),i.forEach((e,r)=>{if(!Array.isArray(e))throw new Error("list of points "+r+" must be an array");if(e.length<3)throw new Error("list of points "+r+" must contain three or more points");e.forEach((e,t)=>{if(!Array.isArray(e))throw new Error("list of points "+r+", point "+t+" must be an array");if(e.length<2)throw new Error("list of points "+r+", point "+t+" must contain by X and Y values")})});let s=n;if(0===n.length){let e=0;s=i.map(r=>r.map(r=>e++))}const u=[];i.forEach(e=>e.forEach(e=>u.push(e)));let a=[];s.forEach(r=>{const t=r.map(e=>u[e]),n=e.fromPoints(t);a=a.concat(e.toSides(n))});let c=e.create(a);return"clockwise"===o&&(c=e.reverse(c)),c}}function requireRectangle(){if(Vc)return Fc;Vc=1;const e=requireVec2(),r=requireGeom2(),{isNumberArray:t}=requireCommonChecks();return Fc=n=>{const{center:o,size:i}=Object.assign({},{center:[0,0],size:[2,2]},n);if(!t(o,2))throw new Error("center must be an array of X and Y values");if(!t(i,2))throw new Error("size must be an array of X and Y values");if(!i.every(e=>e>=0))throw new Error("size values must be positive");if(0===i[0]||0===i[1])return r.create();const s=[i[0]/2,i[1]/2],u=[s[0],-s[1]],a=[e.subtract(e.create(),o,s),e.add(e.create(),o,u),e.add(e.create(),o,s),e.subtract(e.create(),o,u)];return r.fromPoints(a)}}function requireRoundedCuboid(){if(Gc)return Rc;Gc=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec2(),n=requireVec3(),o=requireGeom3(),i=requirePoly3(),{sin:s,cos:u}=requireTrigonometry(),{isGTE:a,isNumberArray:c}=requireCommonChecks(),l=requireCuboid(),createCorners=(o,i,a,c,l,f)=>{const h=r/4*l/c,g=u(h),d=s(h),m=c-l;let q=a*g,p=i[2]-(a-a*d);f||(p=a-a*d-i[2]),q=q>e?q:0;const y=n.add(n.create(),o,[i[0]-a,i[1]-a,p]),v=n.add(n.create(),o,[a-i[0],i[1]-a,p]),w=n.add(n.create(),o,[a-i[0],a-i[1],p]),b=n.add(n.create(),o,[i[0]-a,a-i[1],p]),x=[],E=[],A=[],$=[];for(let e=0;e<=m;e++){const o=m>0?r/4*e/m:0,i=t.fromAngleRadians(t.create(),o);t.scale(i,i,q);const s=n.fromVec2(n.create(),i);x.push(n.add(n.create(),y,s)),n.rotateZ(s,s,[0,0,0],r/4),E.push(n.add(n.create(),v,s)),n.rotateZ(s,s,[0,0,0],r/4),A.push(n.add(n.create(),w,s)),n.rotateZ(s,s,[0,0,0],r/4),$.push(n.add(n.create(),b,s))}return f?[x,E,A,$]:(x.reverse(),E.reverse(),A.reverse(),$.reverse(),[$,A,E,x])},stitchCorners=(e,r)=>{const t=[];for(let n=0;n<e.length;n++){const o=e[n],s=r[n];for(let e=0;e<o.length-1;e++)t.push(i.create([o[e],o[e+1],s[e]])),e<s.length-1&&t.push(i.create([s[e],o[e+1],s[e+1]]))}return t},stitchWalls=(e,r)=>{const t=[];for(let n=0;n<e.length;n++){let o=e[n],s=r[n];const u=o[o.length-1],a=s[s.length-1],c=(n+1)%e.length;o=e[c],s=r[c];const l=o[0],f=s[0];t.push(i.create([u,l,f,a]))}return t},stitchSides=(e,r)=>{e=(e=[e[3],e[2],e[1],e[0]]).map(e=>e.slice().reverse());const t=[];e.forEach(e=>{e.forEach(e=>t.push(e))});const n=[];r.forEach(e=>{e.forEach(e=>n.push(e))});const o=[];for(let e=0;e<n.length;e++){const r=(e+1)%n.length;o.push(i.create([t[e],t[r],n[r],n[e]]))}return o};return Rc=r=>{let{center:t,size:n,roundRadius:s,segments:u}=Object.assign({},{center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32},r);if(!c(t,3))throw new Error("center must be an array of X, Y and Z values");if(!c(n,3))throw new Error("size must be an array of X, Y and Z values");if(!n.every(e=>e>=0))throw new Error("size values must be positive");if(!a(s,0))throw new Error("roundRadius must be positive");if(!a(u,4))throw new Error("segments must be four or more");if(0===n[0]||0===n[1]||0===n[2])return o.create();if(0===s)return l({center:t,size:n});if(n=n.map(e=>e/2),s>n[0]-e||s>n[1]-e||s>n[2]-e)throw new Error("roundRadius must be smaller than the radius of all dimensions");u=Math.floor(u/4);let f=null,h=null,g=[];for(let e=0;e<=u;e++){const r=createCorners(t,n,s,u,e,!0),o=createCorners(t,n,s,u,e,!1);if(0===e&&(g=g.concat(stitchSides(o,r))),f&&(g=g.concat(stitchCorners(f,r),stitchWalls(f,r))),h&&(g=g.concat(stitchCorners(h,o),stitchWalls(h,o))),e===u){let e=r.map(e=>e[0]);g.push(i.create(e)),e=o.map(e=>e[0]),g.push(i.create(e))}f=r,h=o}return o.create(g)},Rc}function requireRoundedCylinder(){if(Nc)return kc;Nc=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec3(),n=requireGeom3(),o=requirePoly3(),{sin:i,cos:s}=requireTrigonometry(),{isGTE:u,isNumberArray:a}=requireCommonChecks(),c=requireCylinder();return kc=l=>{const{center:f,height:h,radius:g,roundRadius:d,segments:m}=Object.assign({},{center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},l);if(!a(f,3))throw new Error("center must be an array of X, Y and Z values");if(!u(h,0))throw new Error("height must be positive");if(!u(g,0))throw new Error("radius must be positive");if(!u(d,0))throw new Error("roundRadius must be positive");if(d>g)throw new Error("roundRadius must be smaller than the radius");if(!u(m,4))throw new Error("segments must be four or more");if(0===h||0===g)return n.create();if(0===d)return c({center:f,height:h,radius:g});const q=[0,0,-h/2],p=[0,0,h/2],y=t.subtract(t.create(),p,q);if(2*d>t.length(y)-e)throw new Error("height must be larger than twice roundRadius");let v;v=Math.abs(y[0])>Math.abs(y[1])?t.fromValues(0,1,0):t.fromValues(1,0,0);const w=t.scale(t.create(),t.normalize(t.create(),y),d),b=t.scale(t.create(),t.normalize(t.create(),t.cross(t.create(),w,v)),g),x=t.scale(t.create(),t.normalize(t.create(),t.cross(t.create(),b,w)),g);t.add(q,q,w),t.subtract(p,p,w);const E=Math.floor(.25*m),fromPoints=e=>{const r=e.map(e=>t.add(e,e,f));return o.create(r)},A=[],$=t.create(),P=t.create();let M;for(let e=0;e<=m;e++){const n=r*e/m,o=t.add(t.create(),t.scale($,b,s(n)),t.scale(P,x,i(n)));if(e>0){let e,n,u=[];u.push(t.add(t.create(),q,o)),u.push(t.add(t.create(),q,M)),u.push(t.add(t.create(),p,M)),u.push(t.add(t.create(),p,o)),A.push(fromPoints(u));for(let a=0;a<=E;a++){const c=r/4*a/E,l=s(c),f=i(c);if(a>0){let r;u=[],r=t.add(t.create(),q,t.subtract($,t.scale($,M,e),t.scale(P,w,n))),u.push(r),r=t.add(t.create(),q,t.subtract($,t.scale($,o,e),t.scale(P,w,n))),u.push(r),a<E&&(r=t.add(t.create(),q,t.subtract($,t.scale($,o,l),t.scale(P,w,f))),u.push(r)),r=t.add(t.create(),q,t.subtract($,t.scale($,M,l),t.scale(P,w,f))),u.push(r),A.push(fromPoints(u)),u=[],r=t.add(t.create(),t.scale($,M,e),t.scale(P,w,n)),t.add(r,r,p),u.push(r),r=t.add(t.create(),t.scale($,o,e),t.scale(P,w,n)),t.add(r,r,p),u.push(r),a<E&&(r=t.add(t.create(),t.scale($,o,l),t.scale(P,w,f)),t.add(r,r,p),u.push(r)),r=t.add(t.create(),t.scale($,M,l),t.scale(P,w,f)),t.add(r,r,p),u.push(r),u.reverse(),A.push(fromPoints(u))}e=l,n=f}}M=o}return n.create(A)},kc}function requireRoundedRectangle(){if(zc)return Oc;zc=1;const{EPS:e,TAU:r}=requireConstants(),t=requireVec2(),n=requireGeom2(),{isGTE:o,isNumberArray:i}=requireCommonChecks(),s=requireRectangle();return Oc=u=>{let{center:a,size:c,roundRadius:l,segments:f}=Object.assign({},{center:[0,0],size:[2,2],roundRadius:.2,segments:32},u);if(!i(a,2))throw new Error("center must be an array of X and Y values");if(!i(c,2))throw new Error("size must be an array of X and Y values");if(!c.every(e=>e>=0))throw new Error("size values must be positive");if(!o(l,0))throw new Error("roundRadius must be positive");if(!o(f,4))throw new Error("segments must be four or more");if(0===c[0]||0===c[1])return n.create();if(0===l)return s({center:a,size:c});if(c=c.map(e=>e/2),l>c[0]-e||l>c[1]-e)throw new Error("roundRadius must be smaller than the radius of all dimensions");const h=Math.floor(f/4),g=t.add(t.create(),a,[c[0]-l,c[1]-l]),d=t.add(t.create(),a,[l-c[0],c[1]-l]),m=t.add(t.create(),a,[l-c[0],l-c[1]]),q=t.add(t.create(),a,[c[0]-l,l-c[1]]),p=[],y=[],v=[],w=[];for(let e=0;e<=h;e++){const n=r/4*e/h,o=t.fromAngleRadians(t.create(),n);t.scale(o,o,l),p.push(t.add(t.create(),g,o)),t.rotate(o,o,t.create(),r/4),y.push(t.add(t.create(),d,o)),t.rotate(o,o,t.create(),r/4),v.push(t.add(t.create(),m,o)),t.rotate(o,o,t.create(),r/4),w.push(t.add(t.create(),q,o))}return n.fromPoints(p.concat(y,v,w))}}function requireSphere(){if(Bc)return Ic;Bc=1;const e=requireEllipsoid(),{isGTE:r}=requireCommonChecks();return Ic=t=>{let{center:n,radius:o,segments:i,axes:s}=Object.assign({},{center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},t);if(!r(o,0))throw new Error("radius must be positive");return o=[o,o,o],e({center:n,radius:o,segments:i,axes:s})}}function requireSquare(){if(jc)return Dc;jc=1;const e=requireRectangle(),{isGTE:r}=requireCommonChecks();return Dc=t=>{let{center:n,size:o}=Object.assign({},{center:[0,0],size:2},t);if(!r(o,0))throw new Error("size must be positive");return o=[o,o],e({center:n,size:o})}}function requireStar(){if(_c)return Lc;_c=1;const{TAU:e}=requireConstants(),r=requireVec2(),t=requireGeom2(),{isGT:n,isGTE:o,isNumberArray:i}=requireCommonChecks(),getPoints=(t,n,o,i)=>{const s=e/t,u=[];for(let e=0;e<t;e++){const t=r.fromAngleRadians(r.create(),s*e+o);r.scale(t,t,n),r.add(t,i,t),u.push(t)}return u};return Lc=s=>{let{center:u,vertices:a,outerRadius:c,innerRadius:l,density:f,startAngle:h}=Object.assign({},{center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0},s);if(!i(u,2))throw new Error("center must be an array of X and Y values");if(!o(a,2))throw new Error("vertices must be two or more");if(!n(c,0))throw new Error("outerRadius must be greater than zero");if(!o(l,0))throw new Error("innerRadius must be greater than zero");if(!o(h,0))throw new Error("startAngle must be greater than zero");if(a=Math.floor(a),f=Math.floor(f),h%=e,0===l){if(!o(f,2))throw new Error("density must be two or more");l=c*((e,r)=>e>0&&r>1&&r<e/2?Math.cos(Math.PI*r/e)/Math.cos(Math.PI*(r-1)/e):0)(a,f)}const g=r.clone(u),d=getPoints(a,c,h,g),m=getPoints(a,l,h+Math.PI/a,g),q=[];for(let e=0;e<a;e++)q.push(d[e]),q.push(m[e]);return t.fromPoints(q)}}function requireMirror(){if(Xc)return Zc;Xc=1;const e=requireFlatten$1(),r=requireMat4(),t=requirePlane$1(),n=requireGeom2(),o=requireGeom3(),i=requirePath2(),mirror=(s,...u)=>{const{origin:a,normal:c}=Object.assign({},{origin:[0,0,0],normal:[0,0,1]},s);if(0===(u=e(u)).length)throw new Error("wrong number of arguments");const l=t.fromNormalAndPoint(t.create(),c,a);if(Number.isNaN(l[0]))throw new Error("the given origin and normal do not define a proper plane");const f=r.mirrorByPlane(r.create(),l),h=u.map(e=>i.isA(e)?i.transform(f,e):n.isA(e)?n.transform(f,e):o.isA(e)?o.transform(f,e):e);return 1===h.length?h[0]:h};return Zc={mirror:mirror,mirrorX:(...e)=>mirror({normal:[1,0,0]},e),mirrorY:(...e)=>mirror({normal:[0,1,0]},e),mirrorZ:(...e)=>mirror({normal:[0,0,1]},e)}}function requireCalculatePlane(){if(Hc)return Uc;Hc=1;const e=requirePlane$1(),r=requireVec3();return Uc=t=>{const n=t.edges;if(n.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const o=n.reduce((e,t)=>r.add(r.create(),e,t[0]),r.create());let i;r.scale(o,o,1/n.length);let s=0;n.forEach(e=>{if(!r.equals(e[0],e[1])){const t=r.squaredDistance(o,e[0]);t>s&&(i=e,s=t)}});const u=n.find(e=>r.equals(e[1],i[0]));return e.fromPoints(e.create(),u[0],i[0],i[1])},Uc}function requireCreate(){if(Wc)return Yc;Wc=1;return Yc=e=>(e||(e=[]),{edges:e})}function requireClone(){if(Qc)return Jc;Qc=1;const e=requireCreate(),r=requireVec3();return Jc=(...t)=>{let n,o;return 1===t.length?(n=e(),o=t[0]):(n=t[0],o=t[1]),n.edges=o.edges.map(e=>[r.clone(e[0]),r.clone(e[1])]),n},Jc}function requireEquals(){if(el)return Kc;el=1;const e=requireVec3();return Kc=(r,t)=>{const n=r.edges,o=t.edges;if(n.length!==o.length)return!1;return n.reduce((r,t,n)=>{const i=o[n],s=e.squaredDistance(t[0],i[0]);return r&&s<Number.EPSILON},!0)}}function requireFromPoints(){if(tl)return rl;tl=1;const e=requireVec3(),r=requireCreate();return rl=t=>{if(!Array.isArray(t))throw new Error("the given points must be an array");if(t.length<3)throw new Error("the given points must contain THREE or more points");const n=[];let o=t[t.length-1];return t.forEach(r=>{2===r.length&&n.push([e.fromVec2(e.create(),o),e.fromVec2(e.create(),r)]),3===r.length&&n.push([o,r]),o=r}),r(n)}}function requireFromSides(){if(ol)return nl;ol=1;const e=requireVec3(),r=requireCreate();return nl=t=>{if(!Array.isArray(t))throw new Error("the given sides must be an array");const n=[];return t.forEach(r=>{n.push([e.fromVec2(e.create(),r[0]),e.fromVec2(e.create(),r[1])])}),r(n)}}function requireIsA(){if(sl)return il;sl=1;return il=e=>!!(e&&"object"==typeof e&&"edges"in e&&Array.isArray(e.edges))}function requireReverse(){if(al)return ul;al=1;const e=requireCreate();return ul=(...r)=>{let t,n;return 1===r.length?(t=e(),n=r[0]):(t=r[0],n=r[1]),t.edges=n.edges.map(e=>[e[1],e[0]]),t},ul}function requireToEdges(){if(ll)return cl;ll=1;return cl=e=>e.edges,cl}function requireLinkedList(){if(dl)return gl;dl=1;const e=function requireLinkedListSort(){return hl?fl:(hl=1,fl=(e,r)=>{let t,n,o,i,s,u=1;do{n=e,e=null;let a=null;for(s=0;n;){s++,o=n;let c=0;for(t=0;t<u&&(c++,o=o.nextZ,o);t++);let l=u;for(;c>0||l>0&&o;)0!==c&&(0===l||!o||r(n)<=r(o))?(i=n,n=n.nextZ,c--):(i=o,o=o.nextZ,l--),a?a.nextZ=i:e=i,i.prevZ=a,a=i;n=o}a.nextZ=null,u*=2}while(s>1);return e})}();class Node{constructor(e,r,t){this.i=e,this.x=r,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}return gl={Node:Node,insertNode:(e,r,t,n)=>{const o=new Node(e,r,t);return n?(o.next=n.next,o.prev=n,n.next.prev=o,n.next=o):(o.prev=o,o.next=o),o},removeNode:e=>{e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)},sortLinked:e}}function requireTriangle$1(){if(ql)return ml;ql=1;return ml={area:(e,r,t)=>(r.y-e.y)*(t.x-r.x)-(r.x-e.x)*(t.y-r.y),pointInTriangle:(e,r,t,n,o,i,s,u)=>(o-s)*(r-u)-(e-s)*(i-u)>=0&&(e-s)*(n-u)-(t-s)*(r-u)>=0&&(t-s)*(i-u)-(o-s)*(n-u)>=0}}function requireLinkedPolygon(){if(yl)return pl;yl=1;const{Node:e,insertNode:r,removeNode:t}=requireLinkedList(),{area:n}=requireTriangle$1(),filterPoints=(e,r)=>{if(!e)return e;r||(r=e);let o,i=e;do{if(o=!1,i.steiner||!equals(i,i.next)&&0!==n(i.prev,i,i.next))i=i.next;else{if(t(i),i=r=i.prev,i===i.next)break;o=!0}}while(o||i!==r);return r},locallyInside=(e,r)=>n(e.prev,e,e.next)<0?n(e,r,e.next)>=0&&n(e,e.prev,r)>=0:n(e,r,e.prev)<0||n(e,e.next,r)<0,intersects=(e,r,t,o)=>{const i=Math.sign(n(e,r,t)),s=Math.sign(n(e,r,o)),u=Math.sign(n(t,o,e)),a=Math.sign(n(t,o,r));return i!==s&&u!==a||(!(0!==i||!onSegment(e,t,r))||(!(0!==s||!onSegment(e,o,r))||(!(0!==u||!onSegment(t,e,o))||!(0!==a||!onSegment(t,r,o)))))},onSegment=(e,r,t)=>r.x<=Math.max(e.x,t.x)&&r.x>=Math.min(e.x,t.x)&&r.y<=Math.max(e.y,t.y)&&r.y>=Math.min(e.y,t.y),signedArea=(e,r,t,n)=>{let o=0;for(let i=r,s=t-n;i<t;i+=n)o+=(e[s]-e[i])*(e[i+1]+e[s+1]),s=i;return o},equals=(e,r)=>e.x===r.x&&e.y===r.y;return pl={cureLocalIntersections:(e,r,n)=>{let o=e;do{const i=o.prev,s=o.next.next;!equals(i,s)&&intersects(i,o,o.next,s)&&locallyInside(i,s)&&locallyInside(s,i)&&(r.push(i.i/n),r.push(o.i/n),r.push(s.i/n),t(o),t(o.next),o=e=s),o=o.next}while(o!==e);return filterPoints(o)},filterPoints:filterPoints,isValidDiagonal:(e,r)=>e.next.i!==r.i&&e.prev.i!==r.i&&!((e,r)=>{let t=e;do{if(t.i!==e.i&&t.next.i!==e.i&&t.i!==r.i&&t.next.i!==r.i&&intersects(t,t.next,e,r))return!0;t=t.next}while(t!==e);return!1})(e,r)&&(locallyInside(e,r)&&locallyInside(r,e)&&((e,r)=>{let t=e,n=!1;const o=(e.x+r.x)/2,i=(e.y+r.y)/2;do{t.y>i!=t.next.y>i&&t.next.y!==t.y&&o<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next}while(t!==e);return n})(e,r)&&(n(e.prev,e,r.prev)||n(e,r.prev,r))||equals(e,r)&&n(e.prev,e,e.next)>0&&n(r.prev,r,r.next)>0),linkedPolygon:(e,n,o,i,s)=>{let u;if(s===signedArea(e,n,o,i)>0)for(let t=n;t<o;t+=i)u=r(t,e[t],e[t+1],u);else for(let t=o-i;t>=n;t-=i)u=r(t,e[t],e[t+1],u);return u&&equals(u,u.next)&&(t(u),u=u.next),u},locallyInside:locallyInside,splitPolygon:(r,t)=>{const n=new e(r.i,r.x,r.y),o=new e(t.i,t.x,t.y),i=r.next,s=t.prev;return r.next=t,t.prev=r,n.next=i,i.prev=n,o.next=n,n.prev=o,s.next=o,o.prev=s,o}}}function requireEarcut(){if(xl)return bl;xl=1;const e=function requireEliminateHoles(){if(wl)return vl;wl=1;const{filterPoints:e,linkedPolygon:r,locallyInside:t,splitPolygon:n}=requireLinkedPolygon(),{area:o,pointInTriangle:i}=requireTriangle$1(),eliminateHole=(r,t)=>{const o=findHoleBridge(r,t);if(!o)return t;const i=n(o,r),s=e(o,o.next);return e(i,i.next),t===o?s:t},findHoleBridge=(e,r)=>{let n=r;const o=e.x,s=e.y;let u,a=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){const e=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=o&&e>a){if(a=e,e===o){if(s===n.y)return n;if(s===n.next.y)return n.next}u=n.x<n.next.x?n:n.next}}n=n.next}while(n!==r);if(!u)return null;if(o===a)return u;const c=u,l=u.x,f=u.y;let h=1/0;n=u;do{if(o>=n.x&&n.x>=l&&o!==n.x&&i(s<f?o:a,s,l,f,s<f?a:o,s,n.x,n.y)){const r=Math.abs(s-n.y)/(o-n.x);t(n,e)&&(r<h||r===h&&(n.x>u.x||n.x===u.x&&sectorContainsSector(u,n)))&&(u=n,h=r)}n=n.next}while(n!==c);return u},sectorContainsSector=(e,r)=>o(e.prev,e,r.prev)<0&&o(r.next,e,e.next)<0,getLeftmost=e=>{let r=e,t=e;do{(r.x<t.x||r.x===t.x&&r.y<t.y)&&(t=r),r=r.next}while(r!==e);return t};return vl=(t,n,o,i)=>{const s=[];for(let e=0,o=n.length;e<o;e++){const u=n[e]*i,a=e<o-1?n[e+1]*i:t.length,c=r(t,u,a,i,!1);c===c.next&&(c.steiner=!0),s.push(getLeftmost(c))}s.sort((e,r)=>e.x-r.x);for(let r=0;r<s.length;r++)o=eliminateHole(s[r],o),o=e(o,o.next);return o}}(),{removeNode:r,sortLinked:t}=requireLinkedList(),{cureLocalIntersections:n,filterPoints:o,isValidDiagonal:i,linkedPolygon:s,splitPolygon:u}=requireLinkedPolygon(),{area:a,pointInTriangle:c}=requireTriangle$1(),earcutLinked=(e,t,i,s,u,a,c)=>{if(!e)return;!c&&a&&indexCurve(e,s,u,a);let l,f,h=e;for(;e.prev!==e.next;)if(l=e.prev,f=e.next,a?isEarHashed(e,s,u,a):isEar(e))t.push(l.i/i),t.push(e.i/i),t.push(f.i/i),r(e),e=f.next,h=f.next;else if((e=f)===h){c?1===c?(e=n(o(e),t,i),earcutLinked(e,t,i,s,u,a,2)):2===c&&splitEarcut(e,t,i,s,u,a):earcutLinked(o(e),t,i,s,u,a,1);break}},isEar=e=>{const r=e.prev,t=e,n=e.next;if(a(r,t,n)>=0)return!1;let o=e.next.next;for(;o!==e.prev;){if(c(r.x,r.y,t.x,t.y,n.x,n.y,o.x,o.y)&&a(o.prev,o,o.next)>=0)return!1;o=o.next}return!0},isEarHashed=(e,r,t,n)=>{const o=e.prev,i=e,s=e.next;if(a(o,i,s)>=0)return!1;const u=o.x<i.x?o.x<s.x?o.x:s.x:i.x<s.x?i.x:s.x,l=o.y<i.y?o.y<s.y?o.y:s.y:i.y<s.y?i.y:s.y,f=o.x>i.x?o.x>s.x?o.x:s.x:i.x>s.x?i.x:s.x,h=o.y>i.y?o.y>s.y?o.y:s.y:i.y>s.y?i.y:s.y,g=zOrder(u,l,r,t,n),d=zOrder(f,h,r,t,n);let m=e.prevZ,q=e.nextZ;for(;m&&m.z>=g&&q&&q.z<=d;){if(m!==e.prev&&m!==e.next&&c(o.x,o.y,i.x,i.y,s.x,s.y,m.x,m.y)&&a(m.prev,m,m.next)>=0)return!1;if(m=m.prevZ,q!==e.prev&&q!==e.next&&c(o.x,o.y,i.x,i.y,s.x,s.y,q.x,q.y)&&a(q.prev,q,q.next)>=0)return!1;q=q.nextZ}for(;m&&m.z>=g;){if(m!==e.prev&&m!==e.next&&c(o.x,o.y,i.x,i.y,s.x,s.y,m.x,m.y)&&a(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;q&&q.z<=d;){if(q!==e.prev&&q!==e.next&&c(o.x,o.y,i.x,i.y,s.x,s.y,q.x,q.y)&&a(q.prev,q,q.next)>=0)return!1;q=q.nextZ}return!0},splitEarcut=(e,r,t,n,s,a)=>{let c=e;do{let e=c.next.next;for(;e!==c.prev;){if(c.i!==e.i&&i(c,e)){let i=u(c,e);return c=o(c,c.next),i=o(i,i.next),earcutLinked(c,r,t,n,s,a),void earcutLinked(i,r,t,n,s,a)}e=e.next}c=c.next}while(c!==e)},indexCurve=(e,r,n,o)=>{let i=e;do{null===i.z&&(i.z=zOrder(i.x,i.y,r,n,o)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,t(i,e=>e.z)},zOrder=(e,r,t,n,o)=>(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-t)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(r=1431655765&((r=858993459&((r=252645135&((r=16711935&((r=32767*(r-n)*o)|r<<8))|r<<4))|r<<2))|r<<1))<<1;return bl=(r,t,n=2)=>{const o=t&&t.length,i=o?t[0]*n:r.length;let u=s(r,0,i,n,!0);const a=[];if(!u||u.next===u.prev)return a;let c,l,f,h,g;if(o&&(u=e(r,t,u,n)),r.length>80*n){c=f=r[0],l=h=r[1];for(let e=n;e<i;e+=n){const t=r[e],n=r[e+1];t<c&&(c=t),n<l&&(l=n),t>f&&(f=t),n>h&&(h=n)}g=Math.max(f-c,h-l),g=0!==g?1/g:0}return earcutLinked(u,a,n,c,l,g),a}}function requirePolygonHierarchy(){if(Pl)return $l;Pl=1;const e=requireGeom2(),r=requirePlane$1(),t=requireVec2(),n=requireVec3(),o=requireCalculatePlane(),i=function requireAssignHoles(){if(Al)return El;Al=1;const{area:e}=requireUtils$1(),{toOutlines:r}=requireGeom2(),{arePointsInside:t}=requirePoly2(),minIndex=(e,r)=>{let t,n;return e.forEach((e,o)=>{const i=r(e);(void 0===n||i<n)&&(t=o,n=i)}),t};return El=n=>{const o=r(n),i=[],s=[];o.forEach((r,t)=>{const n=e(r);n<0?s.push(t):n>0&&i.push(t)});const u=[],a=[];return i.forEach((e,r)=>{const n=o[e];u[r]=[],s.forEach((e,i)=>{const s=o[e];t([s[0]],{vertices:n})&&(u[r].push(e),a[i]||(a[i]=[]),a[i].push(r))})}),s.forEach((e,r)=>{if(a[r]&&a[r].length>1){const t=minIndex(a[r],e=>u[e].length);a[r].forEach((r,n)=>{n!==t&&(u[r]=u[r].filter(r=>r!==e))})}}),u.map((e,r)=>({solid:o[i[r]],holes:e.map(e=>o[e])}))}}();return $l=class PolygonHierarchy{constructor(r){this.plane=o(r);const t=n.orthogonal(n.create(),this.plane),s=n.cross(n.create(),this.plane,t);this.v=n.normalize(s,s),this.u=n.cross(n.create(),this.v,this.plane),this.basisMap=new Map;const u=r.edges.map(e=>e.map(e=>this.to2D(e))),a=e.create(u);this.roots=i(a)}to2D(e){const r=t.fromValues(n.dot(e,this.u),n.dot(e,this.v));return this.basisMap.set(r,e),r}to3D(e){const t=this.basisMap.get(e);if(t)return t;{console.log("Warning: point not in original slice");const t=n.scale(n.create(),this.u,e[0]),o=n.scale(n.create(),this.v,e[1]),i=n.scale(n.create(),r,r[3]),s=n.add(t,t,i);return n.add(o,o,s)}}},$l}function requireToPolygons(){if(Tl)return Ml;Tl=1;const e=requirePoly3(),r=requireEarcut(),t=requirePolygonHierarchy();return Ml=n=>{const o=new t(n),i=[];return o.roots.forEach(({solid:t,holes:n})=>{let s=t.length;const u=[];n.forEach((e,r)=>{u.push(s),s+=e.length});const a=[t,...n].flat(),c=a.flat(),getVertex=e=>o.to3D(a[e]),l=r(c,u);for(let r=0;r<l.length;r+=3){const t=l.slice(r,r+3).map(getVertex);i.push(e.fromPointsAndPlane(t,o.plane))}}),i},Ml}function requireToString(){if(Sl)return Cl;Sl=1;const e=requireVec3();return Cl=r=>{return`[${t=r.edges,t.reduce((r,t)=>r+`[${e.toString(t[0])}, ${e.toString(t[1])}], `,"")}]`;var t},Cl}function requireTransform$1(){if(Vl)return Fl;Vl=1;const e=requireVec3(),r=requireCreate();return Fl=(t,n)=>{const o=n.edges.map(r=>[e.transform(e.create(),r[0],t),e.transform(e.create(),r[1],t)]);return r(o)},Fl}function requireSlice(){return Gl?Rl:(Gl=1,Rl={calculatePlane:requireCalculatePlane(),clone:requireClone(),create:requireCreate(),equals:requireEquals(),fromPoints:requireFromPoints(),fromSides:requireFromSides(),isA:requireIsA(),reverse:requireReverse(),toEdges:requireToEdges(),toPolygons:requireToPolygons(),toString:requireToString(),transform:requireTransform$1()})}function requireExtrudeWalls(){if(zl)return Ol;zl=1;const{EPS:e}=requireConstants(),r=requireVec3(),t=requirePoly3(),n=requireSlice(),gcd=(e,r)=>e===r?e:e<r?gcd(r,e):1===r?1:0===r?e:gcd(r,e%r),repartitionEdges=(e,t)=>{const n=e/t.length;if(1===n)return t;const o=r.fromValues(n,n,n),i=[];return t.forEach(e=>{const t=r.subtract(r.create(),e[1],e[0]);r.divide(t,t,o);let s=e[0];for(let e=1;e<=n;++e){const e=r.add(r.create(),s,t);i.push([s,e]),s=e}}),i},o=e*e/2*Math.sin(Math.PI/3);return Ol=(e,r)=>{let i=n.toEdges(e),s=n.toEdges(r);if(i.length!==s.length){const e=(u=i.length,a=s.length,u*a/gcd(u,a));e!==i.length&&(i=repartitionEdges(e,i)),e!==s.length&&(s=repartitionEdges(e,s))}var u,a;const c=[];return i.forEach((e,r)=>{const n=s[r],i=t.create([e[0],e[1],n[1]]),u=t.measureArea(i);Number.isFinite(u)&&u>o&&c.push(i);const a=t.create([e[0],n[1],n[0]]),l=t.measureArea(a);Number.isFinite(l)&&l>o&&c.push(a)}),c}}function requireExtrudeFromSlices(){if(Bl)return Il;Bl=1;const e=requireMat4(),r=requireGeom2(),t=requireGeom3(),n=requirePoly3(),o=requireSlice(),i=function requireRepair(){if(Nl)return kl;Nl=1;const e=requireVec3(),r=requireCreate();return kl=t=>{if(!t.edges)return t;let n=t.edges;const o=new Map,i=new Map;n=n.filter(r=>!e.equals(r[0],r[1])),n.forEach(e=>{const r=e[0].toString(),t=e[1].toString();o.set(r,e[0]),o.set(t,e[1]),i.set(r,(i.get(r)||0)+1),i.set(t,(i.get(t)||0)-1)});const s=[],u=[];return i.forEach((e,r)=>{e<0&&s.push(r),e>0&&u.push(r)}),s.forEach(r=>{const t=o.get(r);let i,s=1/0;u.forEach(r=>{const n=o.get(r),u=e.distance(t,n);u<s&&(s=u,i=n)}),console.warn(`slice.repair: repairing vertex gap ${t} to ${i} distance ${s}`),n=n.map(e=>e[0].toString()===r?[i,e[1]]:e[1].toString()===r?[e[0],i]:e)}),r(n)},kl}(),s=requireExtrudeWalls(),defaultCallback=(t,i,s)=>{let u=null;return r.isA(s)&&(u=o.fromSides(r.toSides(s))),n.isA(s)&&(u=o.fromPoints(n.toPoints(s))),0===t||1===t?o.transform(e.fromTranslation(e.create(),[0,0,t]),u):null};return Il=(e,r)=>{const u={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:defaultCallback},{numberOfSlices:a,capStart:c,capEnd:l,close:f,repair:h,callback:g}=Object.assign({},u,e);if(a<2)throw new Error("numberOfSlices must be 2 or more");h&&(r=i(r));const d=a-1;let m=null,q=null,p=null,y=[];for(let e=0;e<a;e++){const t=g(e/d,e,r);if(t){if(!o.isA(t))throw new Error("the callback function must return slice objects");if(0===o.toEdges(t).length)throw new Error("the callback function must return slices with one or more edges");p&&(y=y.concat(s(p,t))),0===e&&(m=t),e===a-1&&(q=t),p=t}}if(l){const e=o.toPolygons(q);y=y.concat(e)}if(c){const e=o.toPolygons(m).map(n.invert);y=y.concat(e)}return c||l||f&&!o.equals(q,m)&&(y=y.concat(s(q,m))),t.create(y)}}function requireExtrudeRotate(){if(jl)return Dl;jl=1;const{TAU:e}=requireConstants(),r=requireMat4(),{mirrorX:t}=requireMirror(),n=requireGeom2(),o=requireSlice(),i=requireExtrudeFromSlices();return Dl=(s,u)=>{const a={segments:12,startAngle:0,angle:e,overflow:"cap"};let{segments:c,startAngle:l,angle:f,overflow:h}=Object.assign({},a,s);if(c<3)throw new Error("segments must be greater then 3");l=Math.abs(l)>e?l%e:l,f=Math.abs(f)>e?f%e:f;let g=l+f;if(g=Math.abs(g)>e?g%e:g,g<l){const e=l;l=g,g=e}let d=g-l;if(d<=0&&(d=e),Math.abs(d)<e){const r=e/c;c=Math.floor(Math.abs(d)/r),Math.abs(d)>c*r&&c++}let m=n.toSides(u);if(0===m.length)throw new Error("the given geometry cannot be empty");const q=m.filter(e=>e[0][0]<0),p=m.filter(e=>e[0][0]>=0);q.length>0&&p.length>0&&"cap"===h&&(q.length>p.length?(m=m.map(e=>{let r=e[0],t=e[1];return r=[Math.min(r[0],0),r[1]],t=[Math.min(t[0],0),t[1]],[r,t]}),u=n.create(m),u=t(u)):p.length>=q.length&&(m=m.map(e=>{let r=e[0],t=e[1];return r=[Math.max(r[0],0),r[1]],t=[Math.max(t[0],0),t[1]],[r,t]}),u=n.create(m)));const y=d/c,v=Math.abs(d)<e,w=o.fromSides(n.toSides(u));o.reverse(w,w);const b=r.create();return i(s={numberOfSlices:c+1,capStart:v,capEnd:v,close:!v,callback:(t,n,i)=>{let s=y*n+l;return d===e&&n===c&&(s=l),r.multiply(b,r.fromZRotation(b,s),r.fromXRotation(r.create(),e/4)),o.transform(b,i)}},w)},Dl}function requireRotate(){if(_l)return Ll;_l=1;const e=requireFlatten$1(),r=requireMat4(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),rotate=(i,...s)=>{if(!Array.isArray(i))throw new Error("angles must be an array");if(0===(s=e(s)).length)throw new Error("wrong number of arguments");for(i=i.slice();i.length<3;)i.push(0);const u=i[2],a=i[1],c=i[0],l=r.fromTaitBryanRotation(r.create(),u,a,c),f=s.map(e=>o.isA(e)?o.transform(l,e):t.isA(e)?t.transform(l,e):n.isA(e)?n.transform(l,e):e);return 1===f.length?f[0]:f};return Ll={rotate:rotate,rotateX:(e,...r)=>rotate([e,0,0],r),rotateY:(e,...r)=>rotate([0,e,0],r),rotateZ:(e,...r)=>rotate([0,0,e],r)},Ll}function requireTranslate(){if(Xl)return Zl;Xl=1;const e=requireFlatten$1(),r=requireMat4(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),translate=(i,...s)=>{if(!Array.isArray(i))throw new Error("offset must be an array");if(0===(s=e(s)).length)throw new Error("wrong number of arguments");for(i=i.slice();i.length<3;)i.push(0);const u=r.fromTranslation(r.create(),i),a=s.map(e=>o.isA(e)?o.transform(u,e):t.isA(e)?t.transform(u,e):n.isA(e)?n.transform(u,e):e);return 1===a.length?a[0]:a};return Zl={translate:translate,translateX:(e,...r)=>translate([e,0,0],r),translateY:(e,...r)=>translate([0,e,0],r),translateZ:(e,...r)=>translate([0,0,e],r)}}function requireTorus(){if(Hl)return Ul;Hl=1;const{TAU:e}=requireConstants(),r=requireExtrudeRotate(),{rotate:t}=requireRotate(),{translate:n}=requireTranslate(),o=requireCircle(),{isGT:i,isGTE:s}=requireCommonChecks();return Ul=u=>{const a={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:e},{innerRadius:c,innerSegments:l,outerRadius:f,outerSegments:h,innerRotation:g,startAngle:d,outerRotation:m}=Object.assign({},a,u);if(!i(c,0))throw new Error("innerRadius must be greater than zero");if(!s(l,3))throw new Error("innerSegments must be three or more");if(!i(f,0))throw new Error("outerRadius must be greater than zero");if(!s(h,3))throw new Error("outerSegments must be three or more");if(!s(d,0))throw new Error("startAngle must be positive");if(!i(m,0))throw new Error("outerRotation must be greater than zero");if(c>=f)throw new Error("inner circle is too large to rotate about the outer circle");let q=o({radius:c,segments:l});0!==g&&(q=t([0,0,g],q)),q=n([f,0],q);return r({startAngle:d,angle:m,segments:h},q)}}function requireTriangle(){if(Wl)return Yl;Wl=1;const{NEPS:e}=requireConstants(),r=requireVec2(),t=requireGeom2(),{isNumberArray:n}=requireCommonChecks(),solveAngleFromSSS=(e,r,t)=>Math.acos((e*e+r*r-t*t)/(2*e*r)),solveSAS=r=>{const t=r[0],n=r[1],o=r[2],i=((r,t,n)=>t>e?Math.sqrt(r*r+n*n-2*r*n*Math.cos(t)):Math.sqrt((r-n)*(r-n)+r*n*t*t*(1-t*t/12)))(t,n,o),s=solveAngleFromSSS(i,t,o),u=Math.PI-s-n;return createTriangle(s,n,u,o,i,t)},createTriangle=(e,n,o,i,s,u)=>{const a=r.fromValues(0,0),c=r.fromValues(u,0),l=r.fromValues(i,0);return r.add(l,r.rotate(l,l,[0,0],Math.PI-n),c),t.fromPoints([a,c,l])};return Yl=r=>{let{type:t,values:o}=Object.assign({},{type:"SSS",values:[1,1,1]},r);if("string"!=typeof t)throw new Error("triangle type must be a string");if(t=t.toUpperCase(),"A"!==t[0]&&"S"!==t[0]||"A"!==t[1]&&"S"!==t[1]||"A"!==t[2]&&"S"!==t[2])throw new Error("triangle type must contain three letters; A or S");if(!n(o,3))throw new Error("triangle values must contain three values");if(!o.every(e=>e>0))throw new Error("triangle values must be greater than zero");switch(t){case"AAA":return(r=>{if(Math.abs(r[0]+r[1]+r[2]-Math.PI)>e)throw new Error("AAA triangles require angles that sum to PI");const t=r[0],n=r[1],o=Math.PI-t-n,i=1/Math.sin(o)*Math.sin(t),s=1/Math.sin(o)*Math.sin(n);return createTriangle(t,n,o,i,s,1)})(o);case"AAS":return(r=>{const t=r[0],n=r[1],o=Math.PI+e-t-n;if(o<e)throw new Error("AAS triangles require angles that sum to PI");const i=r[2],s=i/Math.sin(t)*Math.sin(n),u=i/Math.sin(t)*Math.sin(o);return createTriangle(t,n,o,i,s,u)})(o);case"ASA":return(r=>{const t=r[0],n=r[2],o=Math.PI+e-t-n;if(o<e)throw new Error("ASA triangles require angles that sum to PI");const i=r[1],s=i/Math.sin(o)*Math.sin(t),u=i/Math.sin(o)*Math.sin(n);return createTriangle(t,n,o,s,u,i)})(o);case"SAS":return solveSAS(o);case"SSA":return(e=>{const r=e[0],t=e[1],n=e[2],o=Math.asin(t*Math.sin(n)/r),i=Math.PI-o-n,s=r/Math.sin(n)*Math.sin(i);return createTriangle(o,i,n,t,s,r)})(o);case"SSS":return(e=>{const r=e[1],t=e[2],n=e[0];if(r+t<=n||t+n<=r||n+r<=t)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const o=solveAngleFromSSS(t,n,r),i=solveAngleFromSSS(n,r,t),s=Math.PI-o-i;return createTriangle(o,i,s,r,t,n)})(o);default:throw new Error("invalid triangle type, try again")}}}function requireVectorParams(){if(tf)return rf;tf=1;const e={xOffset:0,yOffset:0,input:"?",align:"left",font:function requireSimplex(){return ef?Kl:(ef=1,Kl={height:14,32:[16],33:[10,5,21,5,7,void 0,5,2,4,1,5,0,6,1,5,2],34:[16,4,21,4,14,void 0,12,21,12,14],35:[21,11,25,4,-7,void 0,17,25,10,-7,void 0,4,12,18,12,void 0,3,6,17,6],36:[20,8,25,8,-4,void 0,12,25,12,-4,void 0,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],37:[24,21,21,3,0,void 0,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,void 0,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7],38:[26,23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2],39:[10,5,19,4,20,5,21,6,20,6,18,5,16,4,15],40:[14,11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7],41:[14,3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7],42:[16,8,21,8,9,void 0,3,18,13,12,void 0,13,18,3,12],43:[26,13,18,13,0,void 0,4,9,22,9],44:[10,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],45:[26,4,9,22,9],46:[10,5,2,4,1,5,0,6,1,5,2],47:[22,20,25,2,-7],48:[20,9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21],49:[20,6,17,8,18,11,21,11,0],50:[20,4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0],51:[20,5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],52:[20,13,21,3,7,18,7,void 0,13,21,13,0],53:[20,15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],54:[20,16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7],55:[20,17,21,7,0,void 0,3,21,17,21],56:[20,8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21],57:[20,16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3],58:[10,5,14,4,13,5,12,6,13,5,14,void 0,5,2,4,1,5,0,6,1,5,2],59:[10,5,14,4,13,5,12,6,13,5,14,void 0,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],60:[24,20,18,4,9,20,0],61:[26,4,12,22,12,void 0,4,6,22,6],62:[24,4,18,20,9,4,0],63:[18,3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,void 0,9,2,8,1,9,0,10,1,9,2],64:[27,18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,void 0,12,16,10,14,9,11,9,8,10,6,11,5,void 0,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,void 0,19,16,18,8,18,6,19,5],65:[18,9,21,1,0,void 0,9,21,17,0,void 0,4,7,14,7],66:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,void 0,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0],67:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5],68:[21,4,21,4,0,void 0,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0],69:[19,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11,void 0,4,0,17,0],70:[18,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11],71:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,void 0,13,8,18,8],72:[22,4,21,4,0,void 0,18,21,18,0,void 0,4,11,18,11],73:[8,4,21,4,0],74:[16,12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7],75:[21,4,21,4,0,void 0,18,21,4,7,void 0,9,12,18,0],76:[17,4,21,4,0,void 0,4,0,16,0],77:[24,4,21,4,0,void 0,4,21,12,0,void 0,20,21,12,0,void 0,20,21,20,0],78:[22,4,21,4,0,void 0,4,21,18,0,void 0,18,21,18,0],79:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21],80:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10],81:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,void 0,12,4,18,-2],82:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,void 0,11,11,18,0],83:[20,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],84:[16,8,21,8,0,void 0,1,21,15,21],85:[22,4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21],86:[18,1,21,9,0,void 0,17,21,9,0],87:[24,2,21,7,0,void 0,12,21,7,0,void 0,12,21,17,0,void 0,22,21,17,0],88:[20,3,21,17,0,void 0,17,21,3,0],89:[18,1,21,9,11,9,0,void 0,17,21,9,11],90:[20,17,21,3,0,void 0,3,21,17,21,void 0,3,0,17,0],91:[14,4,25,4,-7,void 0,5,25,5,-7,void 0,4,25,11,25,void 0,4,-7,11,-7],92:[14,0,21,14,-3],93:[14,9,25,9,-7,void 0,10,25,10,-7,void 0,3,25,10,25,void 0,3,-7,10,-7],94:[16,6,15,8,18,10,15,void 0,3,12,8,17,13,12,void 0,8,17,8,0],95:[16,0,-2,16,-2],96:[10,6,21,5,20,4,18,4,16,5,15,6,16,5,17],97:[19,15,14,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],98:[19,4,21,4,0,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],99:[18,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],100:[19,15,21,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],101:[18,3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],102:[12,10,21,8,21,6,20,5,17,5,0,void 0,2,14,9,14],103:[19,15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],104:[19,4,21,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],105:[8,3,21,4,20,5,21,4,22,3,21,void 0,4,14,4,0],106:[10,5,21,6,20,7,21,6,22,5,21,void 0,6,14,6,-3,5,-6,3,-7,1,-7],107:[17,4,21,4,0,void 0,14,14,4,4,void 0,8,8,15,0],108:[8,4,21,4,0],109:[30,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0,void 0,15,10,18,13,20,14,23,14,25,13,26,10,26,0],110:[19,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],111:[19,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14],112:[19,4,14,4,-7,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],113:[19,15,14,15,-7,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],114:[13,4,14,4,0,void 0,4,8,5,11,7,13,9,14,12,14],115:[17,14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3],116:[12,5,21,5,4,6,1,8,0,10,0,void 0,2,14,9,14],117:[19,4,14,4,4,5,1,7,0,10,0,12,1,15,4,void 0,15,14,15,0],118:[16,2,14,8,0,void 0,14,14,8,0],119:[22,3,14,7,0,void 0,11,14,7,0,void 0,11,14,15,0,void 0,19,14,15,0],120:[17,3,14,14,0,void 0,14,14,3,0],121:[16,2,14,8,0,void 0,14,14,8,0,6,-4,4,-6,2,-7,1,-7],122:[17,14,14,3,0,void 0,3,14,14,14,void 0,3,0,14,0],123:[14,9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,void 0,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,void 0,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7],124:[8,4,25,4,-7],125:[14,5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,void 0,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,void 0,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7],126:[24,3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,void 0,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]})}(),height:14,lineSpacing:2.142857142857143,letterSpacing:1,extrudeOffset:0};return rf=(r,t)=>{t||"string"!=typeof r||(r={input:r}),r=r||{};const n=Object.assign({},e,r);return n.input=t||n.input,n}}function requireVectorChar(){if(of)return nf;of=1;const e=requireVectorParams();return nf=(r,t)=>{const{xOffset:n,yOffset:o,input:i,font:s,height:u,extrudeOffset:a}=e(r,t);let c=i.charCodeAt(0);c&&s[c]||(c=63);const l=[].concat(s[c]),f=(u-a)/s.height,h=a/2,g=l.shift()*f,d=[];let m=[];for(let e=0,r=l.length;e<r;e+=2){const r=f*l[e]+n,t=f*l[e+1]+o+h;void 0===l[e]?(d.push(m),m=[],e--):m.push([r,t])}return m.length&&d.push(m),{width:g,height:u,segments:d}}}function requireVectorText(){if(uf)return sf;uf=1;const e=requireVectorChar(),r=requireVectorParams(),translateLine=(e,r)=>{const{x:t,y:n}=Object.assign({x:0,y:0},e||{}),o=r.segments;let i=null,s=null;for(let e=0,r=o.length;e<r;e++){i=o[e];for(let e=0,r=i.length;e<r;e++)s=i[e],i[e]=[s[0]+t,s[1]+n]}return r};return sf=(t,n)=>{const{xOffset:o,yOffset:i,input:s,font:u,height:a,align:c,extrudeOffset:l,lineSpacing:f,letterSpacing:h}=r(t,n);let g,d,m,q,p,y,[v,w]=[o,i],b={width:0,segments:[]};const x=[];let E=[],A=0;const $=v,pushLine=()=>{x.push(b),A=Math.max(A,b.width),b={width:0,segments:[]}};for(g=0,d=s.length;g<d;g++)m=s[g],q=e({xOffset:v,yOffset:w,font:u,height:a,extrudeOffset:l},m),"\n"!==m?(p=q.width*h,b.width+=p,v+=p," "!==m&&(b.segments=b.segments.concat(q.segments))):(v=$,w-=q.height*f,pushLine());for(b.segments.length&&pushLine(),g=0,d=x.length;g<d;g++)b=x[g],A>b.width&&(y=A-b.width,"right"===c?b=translateLine({x:y},b):"center"===c&&(b=translateLine({x:y/2},b))),E=E.concat(b.segments);return E},sf}function requireAreAllShapesTheSameType(){if(ff)return lf;ff=1;const e=requireGeom2(),r=requireGeom3(),t=requirePath2();return lf=n=>{let o;for(const i of n){let n=0;if(e.isA(i)&&(n=1),r.isA(i)&&(n=2),t.isA(i)&&(n=3),o&&n!==o)return!1;o=n}return!0},lf}function requireDegToRad(){if(gf)return hf;gf=1;return hf=e=>.017453292519943295*e}function requireFnNumberSort$1(){if(mf)return df;mf=1;return df=(e,r)=>e-r}function requireInsertSorted$1(){if(pf)return qf;pf=1;return qf=(e,r,t)=>{let n=0,o=e.length;for(;o>n;){const i=Math.floor((n+o)/2);t(r,e[i])>0?n=i+1:o=i}e.splice(n,0,r)}}function requireRadiusToSegments(){if(vf)return yf;vf=1;const{TAU:e}=requireConstants();return yf=(r,t,n)=>{const o=t>0?r*e/t:0,i=n>0?e/n:0;return Math.ceil(Math.max(o,i,4))}}function requireRadToDeg(){if(bf)return wf;bf=1;return wf=e=>57.29577951308232*e}function requireUtils(){return Ef?xf:(Ef=1,xf={areAllShapesTheSameType:requireAreAllShapesTheSameType(),degToRad:requireDegToRad(),flatten:requireFlatten$1(),fnNumberSort:requireFnNumberSort$1(),insertSorted:requireInsertSorted$1(),radiusToSegments:requireRadiusToSegments(),radToDeg:requireRadToDeg()})}function requireFromFakePolygons(){if($f)return Af;$f=1;const e=requireVec2(),r=requireGeom2();return Af=(t,n)=>{const o=n.map(r=>((r,t)=>{if(t.vertices.length<4)return null;const n=[],o=t.vertices.filter((e,r)=>e[2]>0&&(n.push(r),!0));if(2!==o.length)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const i=o.map(t=>{const n=Math.round(t[0]/r)*r+0,o=Math.round(t[1]/r)*r+0;return e.fromValues(n,o)});if(e.equals(i[0],i[1]))return null;const s=n[1]-n[0];if(1!==s&&3!==s)throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return 1===s&&i.reverse(),i})(t,r)).filter(e=>null!==e);return r.create(o)}}function requireTo3DWalls(){if(Mf)return Pf;Mf=1;const e=requireVec3(),r=requireGeom2(),t=requireGeom3(),n=requirePoly3();return Pf=(o,i)=>{const s=r.toSides(i).map(r=>((r,t,o)=>{const i=[e.fromVec2(e.create(),o[0],r),e.fromVec2(e.create(),o[1],r),e.fromVec2(e.create(),o[1],t),e.fromVec2(e.create(),o[0],t)];return n.create(i)})(o.z0,o.z1,r));return t.create(s)}}function requireReTesselateCoplanarPolygons(){if(Ff)return Sf;Ff=1;const{EPS:e}=requireConstants(),r=requireLine2(),t=requireVec2(),n=function requireOrthoNormalBasis(){if(Cf)return Tf;Cf=1;const e=requireMat4(),r=requireVec2(),t=requireVec3(),OrthoNormalBasis=function(e,r){arguments.length<2&&(r=t.orthogonal(t.create(),e)),this.v=t.normalize(t.create(),t.cross(t.create(),e,r)),this.u=t.cross(t.create(),this.v,e),this.plane=e,this.planeorigin=t.scale(t.create(),e,e[3])};return OrthoNormalBasis.prototype={getProjectionMatrix:function(){return e.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const r=t.scale(t.create(),this.plane,this.plane[3]);return e.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,r[0],r[1],r[2],1)},to2D:function(e){return r.fromValues(t.dot(e,this.u),t.dot(e,this.v))},to3D:function(e){const r=t.scale(t.create(),this.u,e[0]),n=t.scale(t.create(),this.v,e[1]),o=t.add(r,r,this.planeorigin);return t.add(n,n,o)}},Tf=OrthoNormalBasis}(),o=requireInterpolateBetween2DPointsForY(),{insertSorted:i,fnNumberSort:s}=requireUtils(),u=requirePoly3();return Sf=a=>{if(a.length<2)return a;const c=[],l=a.length,f=u.plane(a[0]),h=new n(f),g=[],d=[],m=new Map,q=new Map,p=new Map,y=10/e;for(let e=0;e<l;e++){const r=a[e];let n=[],o=r.vertices.length,i=-1;if(o>0){let s,u;for(let a=0;a<o;a++){let o=h.to2D(r.vertices[a]);const c=Math.floor(o[1]*y);let l;p.has(c)?l=p.get(c):p.has(c+1)?l=p.get(c+1):p.has(c-1)?l=p.get(c-1):(l=o[1],p.set(c,o[1])),o=t.fromValues(o[0],l),n.push(o);const f=o[1];(0===a||f<s)&&(s=f,i=a),(0===a||f>u)&&(u=f);let g=q.get(f);g||(g={},q.set(f,g)),g[e]=!0}if(s>=u)n=[],o=0,i=-1;else{let r=m.get(s);r||(r=[],m.set(s,r)),r.push(e)}}n.reverse(),i=o-i-1,g.push(n),d.push(i)}const v=[];q.forEach((e,r)=>v.push(r)),v.sort(s);let w=[],b=[];for(let n=0;n<v.length;n++){const s=[],a=v[n],l=q.get(a);for(let e=0;e<w.length;++e){const r=w[e],t=r.polygonindex;if(l[t]){const n=g[t],o=n.length;let i=r.leftvertexindex,s=r.rightvertexindex;for(;;){let e=i+1;if(e>=o&&(e=0),n[e][1]!==a)break;i=e}let u=s-1;if(u<0&&(u=o-1),n[u][1]===a&&(s=u),i!==r.leftvertexindex&&i===s)w.splice(e,1),--e;else{r.leftvertexindex=i,r.rightvertexindex=s,r.topleft=n[i],r.topright=n[s];let e=i+1;e>=o&&(e=0),r.bottomleft=n[e];let t=s-1;t<0&&(t=o-1),r.bottomright=n[t]}}}let p;if(n>=v.length-1)w=[],p=null;else{p=Number(v[n+1]);const e=.5*(a+p),r=m.get(a);for(const t in r){const n=r[t],s=g[n],u=s.length,c=d[n];let l=c;for(;;){let e=l+1;if(e>=u&&(e=0),s[e][1]!==a)break;if(e===c)break;l=e}let f=c;for(;;){let e=f-1;if(e<0&&(e=u-1),s[e][1]!==a)break;if(e===l)break;f=e}let h=l+1;h>=u&&(h=0);let m=f-1;m<0&&(m=u-1);const q={polygonindex:n,leftvertexindex:l,rightvertexindex:f,topleft:s[l],topright:s[f],bottomleft:s[h],bottomright:s[m]};i(w,q,(r,t)=>{const n=o(r.topleft,r.bottomleft,e),i=o(t.topleft,t.bottomleft,e);return n>i?1:n<i?-1:0})}}for(const n in w){const i=w[n];let u=o(i.topleft,i.bottomleft,a);const c=t.fromValues(u,a);u=o(i.topright,i.bottomright,a);const l=t.fromValues(u,a);u=o(i.topleft,i.bottomleft,p);const f=t.fromValues(u,p);u=o(i.topright,i.bottomright,p);const h=t.fromValues(u,p),g={topleft:c,topright:l,bottomleft:f,bottomright:h,leftline:r.fromPoints(r.create(),c,f),rightline:r.fromPoints(r.create(),h,l)};if(s.length>0){const r=s[s.length-1],n=t.distance(g.topleft,r.topright),o=t.distance(g.bottomleft,r.bottomright);n<e&&o<e&&(g.topleft=r.topleft,g.leftline=r.leftline,g.bottomleft=r.bottomleft,s.splice(s.length-1,1))}s.push(g)}if(n>0){const n=new Set,o=new Set;for(let i=0;i<s.length;i++){const u=s[i];for(let i=0;i<b.length;i++)if(!o.has(i)){const s=b[i];if(t.distance(s.bottomleft,u.topleft)<e&&t.distance(s.bottomright,u.topright)<e){o.add(i);const t=r.direction(u.leftline),a=r.direction(s.leftline),c=t[0]-a[0],l=r.direction(u.rightline),f=r.direction(s.rightline),h=l[0]-f[0],g=Math.abs(c)<e,d=Math.abs(h)<e;(g||c>=0)&&(d||h>=0)&&(u.outpolygon=s.outpolygon,u.leftlinecontinues=g,u.rightlinecontinues=d,n.add(i));break}}}for(let r=0;r<b.length;r++)if(!n.has(r)){const n=b[r];n.outpolygon.rightpoints.push(n.bottomright),t.distance(n.bottomright,n.bottomleft)>e&&n.outpolygon.leftpoints.push(n.bottomleft),n.outpolygon.leftpoints.reverse();const o=n.outpolygon.rightpoints.concat(n.outpolygon.leftpoints).map(e=>h.to3D(e)),i=u.fromPointsAndPlane(o,f);i.vertices.length&&c.push(i)}}for(let r=0;r<s.length;r++){const n=s[r];n.outpolygon?(n.leftlinecontinues||n.outpolygon.leftpoints.push(n.topleft),n.rightlinecontinues||n.outpolygon.rightpoints.push(n.topright)):(n.outpolygon={leftpoints:[],rightpoints:[]},n.outpolygon.leftpoints.push(n.topleft),t.distance(n.topleft,n.topright)>e&&n.outpolygon.rightpoints.push(n.topright))}b=s}return c},Sf}function requireRetessellate(){if(Rf)return Vf;Rf=1;const e=requireGeom3(),r=requirePoly3(),{NEPS:t}=requireConstants(),n=requireReTesselateCoplanarPolygons(),classifyPolygons=e=>{let r=[e];const n=[];for(let e=3;e>=0;e--){const o=[],i=3===e?15e-9:t;r.forEach(r=>{r.sort(byPlaneComponent(e,i));let t=0;for(let s=1;s<r.length;s++)r[s].plane[e]-r[t].plane[e]>i&&(s-t===1?n.push(r[t]):o.push(r.slice(t,s)),t=s);r.length-t===1?n.push(r[t]):o.push(r.slice(t))}),r=o}const o=[];return r.forEach(e=>{e[0]&&(o[e[0].index]=e)}),n.forEach(e=>{o[e.index]=e}),o},byPlaneComponent=(e,r)=>(t,n)=>t.plane[e]-n.plane[e]>r?1:n.plane[e]-t.plane[e]>r?-1:0;return Vf=t=>{if(t.isRetesselated)return t;const o=e.toPolygons(t).map((e,t)=>({vertices:e.vertices,plane:r.plane(e),index:t})),i=classifyPolygons(o),s=[];i.forEach(e=>{if(Array.isArray(e)){const r=n(e);s.push(...r)}else s.push(e)});const u=e.create(s);return u.isRetesselated=!0,u}}function requireMayOverlap(){if(kf)return Gf;kf=1;const{EPS:e}=requireConstants(),r=requireMeasureBoundingBox();return Gf=(t,n)=>{if(0===t.polygons.length||0===n.polygons.length)return!1;const o=r(t),i=o[0],s=o[1],u=r(n),a=u[0],c=u[1];return!(a[0]-s[0]>e)&&(!(i[0]-c[0]>e)&&(!(a[1]-s[1]>e)&&(!(i[1]-c[1]>e)&&(!(a[2]-s[2]>e)&&!(i[2]-c[2]>e)))))}}function requireSplitPolygonByPlane(){if(Df)return Bf;Df=1;const{EPS:e}=requireConstants(),r=requirePlane$1(),t=requireVec3(),n=requirePoly3(),o=function requireSplitLineSegmentByPlane(){if(If)return zf;If=1;const e=requireVec3();return zf=(r,t,n)=>{const o=e.subtract(e.create(),n,t);let i=(r[3]-e.dot(r,t))/e.dot(r,o);return Number.isNaN(i)&&(i=0),i>1&&(i=1),i<0&&(i=0),e.scale(o,o,i),e.add(o,t,o),o},zf}();return Bf=(i,s)=>{const u={type:null,front:null,back:null},a=s.vertices,c=a.length,l=n.plane(s);if(r.equals(l,i))u.type=0;else{let r=!1,s=!1;const f=[],h=-e;for(let n=0;n<c;n++){const o=t.dot(i,a[n])-i[3],u=o<h;f.push(u),o>e&&(r=!0),o<h&&(s=!0)}if(r||s)if(s)if(r){u.type=4;const r=[],s=[];let h=f[0];for(let e=0;e<c;e++){const t=a[e];let n=e+1;n>=c&&(n=0);const u=f[n];if(h===u)h?s.push(t):r.push(t);else{const e=a[n],u=o(i,t,e);h?(s.push(t),s.push(u),r.push(u)):(r.push(t),r.push(u),s.push(u))}h=u}const g=e*e;if(s.length>=3){let e=s[s.length-1];for(let r=0;r<s.length;r++){const n=s[r];t.squaredDistance(n,e)<g&&(s.splice(r,1),r--),e=n}}if(r.length>=3){let e=r[r.length-1];for(let n=0;n<r.length;n++){const o=r[n];t.squaredDistance(o,e)<g&&(r.splice(n,1),n--),e=o}}r.length>=3&&(u.front=n.fromPointsAndPlane(r,l)),s.length>=3&&(u.back=n.fromPointsAndPlane(s,l))}else u.type=3;else u.type=2;else{const e=t.dot(i,l);u.type=e>=0?0:1}}return u}}function requireTree(){if(Zf)return _f;Zf=1;const e=function requireNode(){if(Of)return Nf;Of=1;const e=requirePlane$1(),r=requirePoly3();class Node{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=e}invert(){const r=[this];let t;for(let n=0;n<r.length;n++){t=r[n],t.plane&&(t.plane=e.flip(e.create(),t.plane)),t.front&&r.push(t.front),t.back&&r.push(t.back);const o=t.front;t.front=t.back,t.back=o}}clipPolygons(e,r){let t,n={node:this,polygontreenodes:e};const o=[];do{if(t=n.node,e=n.polygontreenodes,t.plane){const n=t.plane,i=[],s=[],u=r?i:s,a=e.length;for(let r=0;r<a;r++){const t=e[r];t.isRemoved()||t.splitByPlane(n,u,i,s,i)}t.front&&s.length>0&&o.push({node:t.front,polygontreenodes:s});const c=i.length;if(t.back&&c>0)o.push({node:t.back,polygontreenodes:i});else for(let e=0;e<c;e++)i[e].remove()}n=o.pop()}while(void 0!==n)}clipTo(e,r){let t=this;const n=[];do{t.polygontreenodes.length>0&&e.rootnode.clipPolygons(t.polygontreenodes,r),t.front&&n.push(t.front),t.back&&n.push(t.back),t=n.pop()}while(void 0!==t)}addPolygonTreeNodes(e){let t={node:this,polygontreenodes:e};const n=[];do{const e=t.node,o=t.polygontreenodes;if(0===o.length){t=n.pop();continue}if(!e.plane){let t=0;t=Math.floor(o.length/2);const n=o[t].getPolygon();e.plane=r.plane(n)}const i=[],s=[],u=o.length;for(let r=0;r<u;++r)o[r].splitByPlane(e.plane,e.polygontreenodes,s,i,s);i.length>0&&(e.front||(e.front=new Node(e)),u===i.length&&0===s.length?e.front.polygontreenodes=i:n.push({node:e.front,polygontreenodes:i})),s.length>0&&(e.back||(e.back=new Node(e)),u===s.length&&0===i.length?e.back.polygontreenodes=s:n.push({node:e.back,polygontreenodes:s})),t=n.pop()}while(void 0!==t)}}return Nf=Node}(),r=function requirePolygonTreeNode(){if(Lf)return jf;Lf=1;const{EPS:e}=requireConstants(),r=requireVec3(),t=requirePoly3(),n=requireSplitPolygonByPlane();class PolygonTreeNode{constructor(e,r){this.parent=e,this.children=[],this.polygon=r,this.removed=!1}addPolygons(e){if(!this.isRootNode())throw new Error("Assertion failed");const r=this;e.forEach(e=>{r.addChild(e)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const e=this.parent.children,r=e.indexOf(this);if(r<0)throw new Error("Assertion failed");e.splice(r,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(e){let r=[this];const t=[r];let n,o,i,s;for(n=0;n<t.length;++n)for(r=t[n],o=0,i=r.length;o<i;o++)s=r[o],s.polygon?e.push(s.polygon):s.children.length>0&&t.push(s.children)}splitByPlane(e,r,t,n,o){if(this.children.length){const i=[this.children];let s,u,a,c,l;for(s=0;s<i.length;s++)for(l=i[s],u=0,a=l.length;u<a;u++)c=l[u],c.children.length>0?i.push(c.children):c._splitByPlane(e,r,t,n,o)}else this._splitByPlane(e,r,t,n,o)}_splitByPlane(o,i,s,u,a){const c=this.polygon;if(c){const l=t.measureBoundingSphere(c),f=l[3]+e,h=l,g=r.dot(o,h)-o[3];if(g>f)u.push(this);else if(g<-f)a.push(this);else{const e=n(o,c);switch(e.type){case 0:i.push(this);break;case 1:s.push(this);break;case 2:u.push(this);break;case 3:a.push(this);break;case 4:if(e.front){const r=this.addChild(e.front);u.push(r)}if(e.back){const r=this.addChild(e.back);a.push(r)}}}}}addChild(e){const r=new PolygonTreeNode(this,e);return this.children.push(r),r}invertSub(){let e=[this];const r=[e];let n,o,i,s;for(n=0;n<r.length;n++)for(e=r[n],o=0,i=e.length;o<i;o++)s=e[o],s.polygon&&(s.polygon=t.invert(s.polygon)),s.children.length>0&&r.push(s.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let e=[this];const r=[e];for(let t=0;t<r.length;++t){e=r[t];const n=e.length;for(let t=0;t<n;t++){const n=e[t];n.polygon&&(n.polygon=null),n.parent&&(n.parent=null),n.children.length>0&&r.push(n.children),n.children=[]}}}toString(){let e="",r=[this];const t=[r];let n,o,i,s;for(n=0;n<t.length;++n){r=t[n];const u=" ".repeat(n);for(o=0,i=r.length;o<i;o++)s=r[o],e+=`${u}PolygonTreeNode (${s.isRootNode()}): ${s.children.length}`,s.polygon?e+=`\n ${u}polygon: ${s.polygon.vertices}\n`:e+="\n",s.children.length>0&&t.push(s.children)}return e}}return jf=PolygonTreeNode}();return _f=class Tree{constructor(t){this.polygonTree=new r,this.rootnode=new e(null),t&&this.addPolygons(t)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(e,r=!1){this.rootnode.clipTo(e,r)}allPolygons(){const e=[];return this.polygonTree.getPolygons(e),e}addPolygons(e){const r=new Array(e.length);for(let t=0;t<e.length;t++)r[t]=this.polygonTree.addChild(e[t]);this.rootnode.addPolygonTreeNodes(r)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}}}function requireTrees(){return Uf?Xf:(Uf=1,Xf={Tree:requireTree()})}function requireIntersectGeom3(){if(Jf)return Wf;Jf=1;const e=requireFlatten$1(),r=requireRetessellate(),t=function requireIntersectGeom3Sub(){if(Yf)return Hf;Yf=1;const e=requireGeom3(),r=requireMayOverlap(),{Tree:t}=requireTrees();return Hf=(n,o)=>{if(!r(n,o))return e.create();const i=new t(e.toPolygons(n)),s=new t(e.toPolygons(o));i.invert(),s.clipTo(i),s.invert(),i.clipTo(s),s.clipTo(i),i.addPolygons(s.allPolygons()),i.invert();const u=i.allPolygons();return e.create(u)}}();return Wf=(...n)=>{let o=(n=e(n)).shift();return n.forEach(e=>{o=t(o,e)}),o=r(o),o},Wf}function requireIntersectGeom2(){if(Kf)return Qf;Kf=1;const e=requireFlatten$1(),r=requireGeom3(),t=requireMeasureEpsilon(),n=requireFromFakePolygons(),o=requireTo3DWalls(),i=requireIntersectGeom3();return Qf=(...s)=>{const u=(s=e(s)).map(e=>o({z0:-1,z1:1},e)),a=i(u),c=t(a);return n(c,r.toPolygons(a))},Qf}function requireIntersect(){if(rh)return eh;rh=1;const e=requireFlatten$1(),r=requireAreAllShapesTheSameType(),t=requireGeom2(),n=requireGeom3(),o=requireIntersectGeom2(),i=requireIntersectGeom3();return eh=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");if(!r(s))throw new Error("only intersect of the types are supported");const u=s[0];return t.isA(u)?o(s):n.isA(u)?i(s):u},eh}function requireScission(){if(ih)return oh;ih=1;const e=requireFlatten$1(),r=requireGeom3(),t=function requireScissionGeom3(){if(nh)return th;nh=1;const e=requireVec3(),r=requireMeasureEpsilon(),t=requireGeom3();return th=n=>{const o=r(n),i=t.toPolygons(n),s=i.length,u=new Map,a=e.create();i.forEach((r,t)=>{r.vertices.forEach(r=>{((e,r,t)=>{const n=`${r}`,o=e.get(n);void 0===o?e.set(n,[t]):o.push(t)})(u,e.snap(a,r,o),t)})});const c=i.map(r=>{let t=[];return r.vertices.forEach(r=>{t=t.concat(((e,r)=>{const t=`${r}`;return e.get(t)})(u,e.snap(a,r,o)))}),{e:1,d:(n=t,n.sort((e,r)=>e-r).filter((e,r,t)=>!r||e!==t[r-1]))};var n});u.clear();let l=0;const f=c.length;for(let e=0;e<f;e++){const r=c[e];if(r.e>0){const t=new Array(s);t[e]=!0;do{l=0,t.forEach((e,r)=>{const n=c[r];if(n.e>0){n.e=-1;for(let e=0;e<n.d.length;e++)t[n.d[e]]=!0;l++}})}while(l>0);r.indexes=t}}const h=[];for(let e=0;e<f;e++)if(c[e].indexes){const r=[];c[e].indexes.forEach((e,t)=>r.push(i[t])),h.push(t.create(r))}return h}}();return oh=(...n)=>{if(0===(n=e(n)).length)throw new Error("wrong number of arguments");const o=n.map(e=>r.isA(e)?t(e):e);return 1===o.length?o[0]:o}}function requireSubtractGeom3(){if(ch)return ah;ch=1;const e=requireFlatten$1(),r=requireRetessellate(),t=function requireSubtractGeom3Sub(){if(uh)return sh;uh=1;const e=requireGeom3(),r=requireMayOverlap(),{Tree:t}=requireTrees();return sh=(n,o)=>{if(!r(n,o))return e.clone(n);const i=new t(e.toPolygons(n)),s=new t(e.toPolygons(o));i.invert(),i.clipTo(s),s.clipTo(i,!0),i.addPolygons(s.allPolygons()),i.invert();const u=i.allPolygons();return e.create(u)}}();return ah=(...n)=>{let o=(n=e(n)).shift();return n.forEach(e=>{o=t(o,e)}),o=r(o),o},ah}function requireSubtractGeom2(){if(fh)return lh;fh=1;const e=requireFlatten$1(),r=requireGeom3(),t=requireMeasureEpsilon(),n=requireFromFakePolygons(),o=requireTo3DWalls(),i=requireSubtractGeom3();return lh=(...s)=>{const u=(s=e(s)).map(e=>o({z0:-1,z1:1},e)),a=i(u),c=t(a);return n(c,r.toPolygons(a))},lh}function requireSubtract(){if(gh)return hh;gh=1;const e=requireFlatten$1(),r=requireAreAllShapesTheSameType(),t=requireGeom2(),n=requireGeom3(),o=requireSubtractGeom2(),i=requireSubtractGeom3();return hh=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");if(!r(s))throw new Error("only subtract of the types are supported");const u=s[0];return t.isA(u)?o(s):n.isA(u)?i(s):u},hh}function requireUnionGeom3Sub(){if(mh)return dh;mh=1;const e=requireGeom3(),r=requireMayOverlap(),{Tree:t}=requireTrees(),unionForNonIntersecting=(r,t)=>{let n=e.toPolygons(r);return n=n.concat(e.toPolygons(t)),e.create(n)};return dh=(n,o)=>{if(!r(n,o))return unionForNonIntersecting(n,o);const i=new t(e.toPolygons(n)),s=new t(e.toPolygons(o));i.clipTo(s,!1),s.clipTo(i),s.invert(),s.clipTo(i),s.invert();const u=i.allPolygons().concat(s.allPolygons());return e.create(u)}}function requireUnionGeom3(){if(ph)return qh;ph=1;const e=requireFlatten$1(),r=requireRetessellate(),t=requireUnionGeom3Sub();return qh=(...n)=>{let o;for(n=e(n),o=1;o<n.length;o+=2)n.push(t(n[o-1],n[o]));let i=n[o-1];return i=r(i),i},qh}function requireUnionGeom2(){if(vh)return yh;vh=1;const e=requireFlatten$1(),r=requireGeom3(),t=requireMeasureEpsilon(),n=requireFromFakePolygons(),o=requireTo3DWalls(),i=requireUnionGeom3();return yh=(...s)=>{const u=(s=e(s)).map(e=>o({z0:-1,z1:1},e)),a=i(u),c=t(a);return n(c,r.toPolygons(a))},yh}function requireUnion(){if(bh)return wh;bh=1;const e=requireFlatten$1(),r=requireAreAllShapesTheSameType(),t=requireGeom2(),n=requireGeom3(),o=requireUnionGeom2(),i=requireUnionGeom3();return wh=(...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");if(!r(s))throw new Error("only unions of the same type are supported");const u=s[0];return t.isA(u)?o(s):n.isA(u)?i(s):u},wh}function requireOffsetFromPoints(){if($h)return Ah;$h=1;const{EPS:e,TAU:r}=requireConstants(),t=requireIntersect$1(),n=requireLine2(),o=requireVec2(),i=requireArea();return Ah=(s,u)=>{let{delta:a,corners:c,closed:l,segments:f}=Object.assign({},{delta:1,corners:"edge",closed:!1,segments:16},s);if(Math.abs(a)<e)return u;let h=s.closed?i(u):1;0===h&&(h=1);const g=h>0&&a>=0||h<0&&a<0;a=Math.abs(a);let d=null,m=[];const q=[],p=o.create(),y=u.length;for(let e=0;e<y;e++){const r=(e+1)%y,n=u[e],i=u[r];g?o.subtract(p,n,i):o.subtract(p,i,n),o.normal(p,p),o.normalize(p,p),o.scale(p,p,a);const s=o.add(o.create(),n,p),c=o.add(o.create(),i,p),f=[s,c];if(null!=d&&(l||!l&&0!==r)){const e=t(d[0],d[1],f[0],f[1]);e?(m.pop(),f[0]=e):q.push({c:n,s0:d,s1:f})}d=[s,c],(0!==r||l)&&(m.push(f[0]),m.push(f[1]))}if(l&&null!=d){const e=m[0],r=m[1],n=t(d[0],d[1],e,r);if(n)m[0]=n,m.pop();else{const t=u[0],n=[e,r];q.push({c:t,s0:d,s1:n})}}if("edge"===c){const e=new Map;m.forEach((r,t)=>e.set(r,t));const r=n.create(),t=n.create();q.forEach(o=>{n.fromPoints(r,o.s0[0],o.s0[1]),n.fromPoints(t,o.s1[0],o.s1[1]);const i=n.intersectPointOfLines(r,t);if(Number.isFinite(i[0])&&Number.isFinite(i[1])){const r=o.s0[1],t=e.get(r);m[t]=i,m[(t+1)%m.length]=void 0}else{const r=o.s1[0],t=e.get(r);m[t]=void 0}}),m=m.filter(e=>void 0!==e)}if("round"===c){let e=Math.floor(f/4);const t=o.create();q.forEach(n=>{let i=o.angle(o.subtract(t,n.s1[0],n.c));if(i-=o.angle(o.subtract(t,n.s0[1],n.c)),g&&i<0&&(i+=Math.PI,i<0&&(i+=Math.PI)),!g&&i>0&&(i-=Math.PI,i>0&&(i-=Math.PI)),0!==i){e=Math.floor(f*(Math.abs(i)/r));const s=i/e,u=o.angle(o.subtract(t,n.s0[1],n.c)),c=[];for(let r=1;r<e;r++){const e=u+s*r,t=o.fromAngleRadians(o.create(),e);o.scale(t,t,a),o.add(t,t,n.c),c.push(t)}if(c.length>0){const e=n.s0[1];let r=m.findIndex(r=>o.equals(e,r));r=(r+1)%m.length,m.splice(r,0,...c)}}else{const e=n.s1[0],r=m.findIndex(r=>o.equals(e,r));m.splice(r,1)}})}return m}}function requireExpandShell(){if(Fh)return Sh;Fh=1;const{EPS:e,TAU:r}=requireConstants(),t=requireMat4(),n=requireVec3(),o=requireFnNumberSort$1(),i=requireGeom3(),s=requirePoly3(),u=requireSphere(),a=requireRetessellate(),c=requireUnionGeom3Sub(),l=function requireExtrudePolygon(){if(Ch)return Th;Ch=1;const e=requireMat4(),r=requireVec3(),t=requireGeom3(),n=requirePoly3();return Th=(o,i)=>{r.dot(n.plane(i),o)>0&&(i=n.invert(i));const s=[i],u=n.transform(e.fromTranslation(e.create(),o),i),a=i.vertices.length;for(let e=0;e<a;e++){const r=e<a-1?e+1:0,t=n.create([i.vertices[e],u.vertices[e],u.vertices[r],i.vertices[r]]);s.push(t)}return s.push(n.invert(u)),t.create(s)}}(),mapPlaneToVertex=(e,r,t)=>{const n=r.toString();if(e.has(n)){e.get(n)[1].push(t)}else{const o=[r,[t]];e.set(n,o)}},mapPlaneToEdge=(e,r,t)=>{const n=r[0].toString(),o=r[1].toString(),i=n<o?`${n},${o}`:`${o},${n}`;if(e.has(i)){e.get(i)[1].push(t)}else{const n=[r,[t]];e.set(i,n)}},addUniqueAngle=(e,r)=>{e.findIndex(e=>e===r)<0&&e.push(r)};return Sh=(f,h)=>{const{delta:g,segments:d}=Object.assign({},{delta:1,segments:12},f);let m=i.create();const q=new Map,p=new Map,y=n.create(),v=n.create();return i.toPolygons(h).forEach((e,r)=>{const o=n.scale(n.create(),s.plane(e),2*g),i=s.transform(t.fromTranslation(t.create(),n.scale(n.create(),o,-.5)),e),u=l(o,i);m=c(m,u);const a=e.vertices;for(let r=0;r<a.length;r++){mapPlaneToVertex(q,a[r],s.plane(e));const t=(r+1)%a.length,n=[a[r],a[t]];mapPlaneToEdge(p,n,s.plane(e))}}),p.forEach(t=>{const u=t[0],a=t[1],l=u[0],f=u[1],h=n.subtract(n.create(),f,l);n.normalize(h,h);const q=a[0],p=n.cross(n.create(),q,h);let w=[];for(let e=0;e<d;e++)addUniqueAngle(w,e*r/d);for(let e=0,t=a.length;e<t;e++){const t=a[e],o=n.dot(p,t),i=n.dot(q,t);let s=Math.atan2(o,i);s<0&&(s+=r),addUniqueAngle(w,s),s=Math.atan2(-o,-i),s<0&&(s+=r),addUniqueAngle(w,s)}w=w.sort(o);const b=w.length;let x,E;const A=[],$=[],P=[];for(let r=-1;r<b;r++){const t=w[r<0?r+b:r],o=Math.sin(t),i=Math.cos(t);n.scale(y,q,i*g),n.scale(v,p,o*g),n.add(y,y,v);const u=n.add(n.create(),l,y),a=n.add(n.create(),f,y);let c=!1;if(r>=0&&n.distance(u,x)<e&&(c=!0),!c){if(r>=0){A.push(u),$.push(a);const e=[E,a,u,x],r=s.create(e);P.push(r)}x=u,E=a}}$.reverse(),P.push(s.create(A)),P.push(s.create($));const M=i.create(P);m=c(m,M)}),q.forEach(e=>{const r=e[0],t=e[1],o=t[0];let i=null,s=0;for(let e=1;e<t.length;e++){const r=t[e],u=n.cross(y,o,r),a=n.length(u);a>.05&&a>s&&(s=a,i=r)}i||(i=n.orthogonal(y,o));const a=n.cross(y,o,i);n.normalize(a,a);const l=n.cross(v,a,o),f=u({center:[r[0],r[1],r[2]],radius:g,segments:d,axes:[o,a,l]});m=c(m,f)}),a(m)},Sh}function requireExpandPath2(){if(kh)return Gh;kh=1;const e=requireArea(),r=requireVec2(),t=requireGeom2(),n=requirePath2(),o=requireOffsetFromPoints();return Gh=(i,s)=>{i=Object.assign({},{delta:1,corners:"edge",segments:16},i);const{delta:u,corners:a,segments:c}=i;if(u<=0)throw new Error("the given delta must be positive for paths");if("edge"!==a&&"chamfer"!==a&&"round"!==a)throw new Error('corners must be "edge", "chamfer", or "round"');const l=s.isClosed,f=n.toPoints(s);if(0===f.length)throw new Error("the given geometry cannot be empty");const h={points:f,external:o({delta:u,corners:a,segments:c,closed:l},f),internal:o({delta:-u,corners:a,segments:c,closed:l},f)};return s.isClosed?(r=>{let{external:o,internal:i}=r;e(o)<0?o=o.reverse():i=i.reverse();const s=n.fromPoints({closed:!0},o),u=n.fromPoints({closed:!0},i),a=t.toSides(t.fromPoints(n.toPoints(s))),c=t.toSides(t.fromPoints(n.toPoints(u)));return a.push(...c),t.create(a)})(h):((e,n,o,i)=>{const{points:s,external:u,internal:a}=e,c=Math.floor(n/2),l=[],f=[];if("round"===o&&c>0){const e=Math.PI/c,t=s[s.length-1],n=r.angle(r.subtract(r.create(),u[u.length-1],t)),o=s[0],h=r.angle(r.subtract(r.create(),a[0],o));for(let s=1;s<c;s++){let u=n+e*s,a=r.fromAngleRadians(r.create(),u);r.scale(a,a,i),r.add(a,a,t),l.push(a),u=h+e*s,a=r.fromAngleRadians(r.create(),u),r.scale(a,a,i),r.add(a,a,o),f.push(a)}}const h=[];return h.push(...u,...l,...a.reverse(),...f),t.fromPoints(h)})(h,c,a,u)}}function requireExpand(){if(Oh)return Nh;Oh=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2(),o=function requireExpandGeom2(){if(Mh)return Ph;Mh=1;const e=requireGeom2(),r=requireOffsetFromPoints();return Ph=(t,n)=>{const{delta:o,corners:i,segments:s}=Object.assign({},{delta:1,corners:"edge",segments:16},t);if("edge"!==i&&"chamfer"!==i&&"round"!==i)throw new Error('corners must be "edge", "chamfer", or "round"');const u=e.toOutlines(n).map(e=>r(t={delta:o,corners:i,closed:!0,segments:s},e)).reduce((r,t)=>r.concat(e.toSides(e.fromPoints(t))),[]);return e.create(u)}}(),i=function requireExpandGeom3(){if(Rh)return Vh;Rh=1;const e=requireGeom3(),r=requireUnion(),t=requireExpandShell();return Vh=(n,o)=>{const{delta:i,corners:s,segments:u}=Object.assign({},{delta:1,corners:"round",segments:12},n);if("round"!==s)throw new Error('corners must be "round" for 3D geometries');if(0===e.toPolygons(o).length)throw new Error("the given geometry cannot be empty");const a=t(n={delta:i,corners:s,segments:u},o);return r(o,a)}}(),s=requireExpandPath2();return Nh=(u,...a)=>{if(0===(a=e(a)).length)throw new Error("wrong number of arguments");const c=a.map(e=>n.isA(e)?s(u,e):r.isA(e)?o(u,e):t.isA(e)?i(u,e):e);return 1===c.length?c[0]:c}}function requireOffset(){if(Lh)return jh;Lh=1;const e=requireFlatten$1(),r=requireGeom2(),t=requirePath2(),n=function requireOffsetGeom2(){if(Ih)return zh;Ih=1;const e=requireGeom2(),r=requirePoly2(),t=requireOffsetFromPoints();return zh=(n,o)=>{const{delta:i,corners:s,segments:u}=Object.assign({},{delta:1,corners:"edge",segments:0},n);if("edge"!==s&&"chamfer"!==s&&"round"!==s)throw new Error('corners must be "edge", "chamfer", or "round"');const a=e.toOutlines(o),c=a.map(e=>{const o=a.reduce((t,n)=>t+r.arePointsInside(e,r.create(n)),0);return t(n={delta:o%2==0?i:-i,corners:s,closed:!0,segments:u},e)}).reduce((r,t)=>r.concat(e.toSides(e.fromPoints(t))),[]);return e.create(c)}}(),o=function requireOffsetPath2(){if(Dh)return Bh;Dh=1;const e=requirePath2(),r=requireOffsetFromPoints();return Bh=(t,n)=>{const o={delta:1,corners:"edge",closed:n.isClosed,segments:16},{delta:i,corners:s,closed:u,segments:a}=Object.assign({},o,t);if("edge"!==s&&"chamfer"!==s&&"round"!==s)throw new Error('corners must be "edge", "chamfer", or "round"');const c=r(t={delta:i,corners:s,closed:u,segments:a},e.toPoints(n));return e.fromPoints({closed:u},c)}}();return jh=(i,...s)=>{if(0===(s=e(s)).length)throw new Error("wrong number of arguments");const u=s.map(e=>t.isA(e)?o(i,e):r.isA(e)?n(i,e):e);return 1===u.length?u[0]:u}}function requireExtrudeLinearGeom2(){if(Uh)return Xh;Uh=1;const e=requireMat4(),r=requireVec3(),t=requireGeom2(),n=requireSlice(),o=requireExtrudeFromSlices();return Xh=(i,s)=>{let{offset:u,twistAngle:a,twistSteps:c,repair:l}=Object.assign({},{offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0},i);if(c<1)throw new Error("twistSteps must be 1 or more");0===a&&(c=1);const f=r.clone(u),h=t.toSides(s);if(0===h.length)throw new Error("the given geometry cannot be empty");const g=n.fromSides(h);f[2]<0&&n.reverse(g,g);const d=e.create();return o(i={numberOfSlices:c+1,capStart:!0,capEnd:!0,repair:l,callback:(t,o,i)=>{const s=o/c*a,u=r.scale(r.create(),f,o/c);return e.multiply(d,e.fromZRotation(d,s),e.fromTranslation(e.create(),u)),n.transform(d,i)}},g)}}function requireExtrudeLinearPath2(){if(Yh)return Hh;Yh=1;const e=requireGeom2(),r=requirePath2(),t=requireExtrudeLinearGeom2();return Hh=(n,o)=>{if(!o.isClosed)throw new Error("extruded path must be closed");const i=r.toPoints(o),s=e.fromPoints(i);return t(n,s)}}function requireExtrudeLinear(){if(Jh)return Wh;Jh=1;const e=requireFlatten$1(),r=requireGeom2(),t=requirePath2(),n=requireExtrudeLinearGeom2(),o=requireExtrudeLinearPath2();return Wh=(i,...s)=>{const{height:u,twistAngle:a,twistSteps:c,repair:l}=Object.assign({},{height:1,twistAngle:0,twistSteps:1,repair:!0},i);if(0===(s=e(s)).length)throw new Error("wrong number of arguments");i={offset:[0,0,u],twistAngle:a,twistSteps:c,repair:l};const f=s.map(e=>t.isA(e)?o(i,e):r.isA(e)?n(i,e):e);return 1===f.length?f[0]:f}}function requireExtrudeRectangular(){if(ng)return tg;ng=1;const e=requireFlatten$1(),r=requireGeom2(),t=requirePath2(),n=function requireExtrudeRectangularPath2(){if(Kh)return Qh;Kh=1;const e=requirePath2(),r=requireExpand(),t=requireExtrudeLinearGeom2();return Qh=(n,o)=>{const{size:i,height:s}=Object.assign({},{size:1,height:1},n);if(n.delta=i,n.offset=[0,0,s],0===e.toPoints(o).length)throw new Error("the given geometry cannot be empty");const u=r(n,o);return t(n,u)}}(),o=function requireExtrudeRectangularGeom2(){if(rg)return eg;rg=1;const{area:e}=requireUtils$1(),r=requireGeom2(),t=requirePath2(),n=requireExpand(),o=requireExtrudeLinearGeom2();return eg=(i,s)=>{const{size:u,height:a}=Object.assign({},{size:1,height:1},i);i.delta=u,i.offset=[0,0,a];const c=r.toOutlines(s);if(0===c.length)throw new Error("the given geometry cannot be empty");const l=c.map(r=>(e(r)<0&&r.reverse(),n(i,t.fromPoints({closed:!0},r)))).reduce((e,t)=>e.concat(r.toSides(t)),[]),f=r.create(l);return o(i,f)}}();return tg=(i,...s)=>{const{size:u,height:a}=Object.assign({},{size:1,height:1},i);if(0===(s=e(s)).length)throw new Error("wrong number of arguments");if(u<=0)throw new Error("size must be positive");if(a<=0)throw new Error("height must be positive");const c=s.map(e=>t.isA(e)?n(i,e):r.isA(e)?o(i,e):e);return 1===c.length?c[0]:c}}function requireExtrudeHelical(){if(ig)return og;ig=1;const{TAU:e}=requireConstants(),r=requireMat4(),t=requireGeom2(),n=requireExtrudeFromSlices(),o=requireSlice();return og=(i,s)=>{const u={angle:e,startAngle:0,pitch:10,height:0,endOffset:0,segmentsPerRotation:32};let{angle:a,startAngle:c,pitch:l,height:f,endOffset:h,segmentsPerRotation:g}=Object.assign({},u,i);0!=f&&(l=f/(a/e));if(g<3)throw new Error("The number of segments per rotation needs to be at least 3.");const d=t.toSides(s);if(0===d.length)throw new Error("The given geometry cannot be empty");const m=d.filter(e=>e[0][0]>=0);let q=o.fromSides(d);0===m.length&&(q=o.reverse(q));const p=Math.round(g/e*Math.abs(a)),y=p>=2?p:2,v=r.create(),w=r.create();return n({numberOfSlices:y+1,callback:(t,n,i)=>{const s=c+a/y*n,u=h/y*n,f=(s-c)/e*l;return r.multiply(v,r.fromTranslation(r.create(),[u,0,f*Math.sign(a)]),r.fromXRotation(r.create(),-e/4*Math.sign(a))),r.multiply(w,r.fromZRotation(r.create(),s),v),o.transform(w,i)}},q)},og}function requireProject(){if(ug)return sg;ug=1;const e=requireFlatten$1(),r=requireAboutEqualNormals(),t=requirePlane$1(),n=requireMat4(),o=requireGeom2(),i=requireGeom3(),s=requirePoly3(),u=requireMeasureEpsilon(),a=requireUnionGeom2();return sg=(c,...l)=>{const{axis:f,origin:h}=Object.assign({},{axis:[0,0,1],origin:[0,0,0]},c);if(0===(l=e(l)).length)throw new Error("wrong number of arguments");c={axis:f,origin:h};const g=l.map(e=>i.isA(e)?((e,c)=>{const l=t.fromNormalAndPoint(t.create(),e.axis,e.origin);if(Number.isNaN(l[0])||Number.isNaN(l[1])||Number.isNaN(l[2])||Number.isNaN(l[3]))throw new Error("project: invalid axis or origin");const f=u(c),h=f*f*Math.sqrt(3)/4;if(0===f)return o.create();const g=i.toPolygons(c);let d=[];for(let e=0;e<g.length;e++){const n=g[e].vertices.map(e=>t.projectionOfPoint(l,e)),o=s.create(n),i=s.plane(o);r(l,i)&&(s.measureArea(o)<h||d.push(o))}if(!r(l,[0,0,1])){const e=n.fromVectorRotation(n.create(),l,[0,0,1]);d=d.map(r=>s.transform(e,r))}d=d.sort((e,r)=>s.measureArea(r)-s.measureArea(e));const m=d.map(e=>o.fromPoints(e.vertices));return a(m)})(c,e):e);return 1===g.length?g[0]:g}}function requireHullPoints2(){if(fg)return lg;fg=1;const e=requireVec2(),ccw=(e,r,t)=>(r[0]-e[0])*(t[1]-e[1])-(r[1]-e[1])*(t[0]-e[0]),fakeAtan2=(e,r)=>0===e&&0===r?-1/0:-r/e;return lg=r=>{let t=e.fromValues(1/0,1/0);r.forEach(e=>{(e[1]<t[1]||e[1]===t[1]&&e[0]<t[0])&&(t=e)});const n=[];r.forEach(r=>{const o=fakeAtan2(r[1]-t[1],r[0]-t[0]),i=e.squaredDistance(r,t);n.push({point:r,angle:o,distSq:i})}),n.sort((e,r)=>e.angle!==r.angle?e.angle-r.angle:e.distSq-r.distSq);const o=[];return n.forEach(e=>{let r=o.length;for(;r>1&&ccw(o[r-2],o[r-1],e.point)<=Number.EPSILON;)o.pop(),r=o.length;o.push(e.point)}),o},lg}function requireToUniquePoints(){if(gg)return hg;gg=1;const e=requireGeom2(),r=requireGeom3(),t=requirePath2();return hg=n=>{const o=new Set,i=[],addPoint=e=>{const r=e.toString();o.has(r)||(i.push(e),o.add(r))};return n.forEach(n=>{e.isA(n)?e.toPoints(n).forEach(addPoint):r.isA(n)?r.toPoints(n).forEach(e=>e.forEach(addPoint)):t.isA(n)&&t.toPoints(n).forEach(addPoint)}),i},hg}function requireHullPoints3(){if(vg)return yg;vg=1;const e=requirePoly3(),r=requireQuickhull();return yg=t=>r(t,{skipTriangulation:!0}).map(r=>{const n=r.map(e=>t[e]);return e.create(n)})}function requireHull(){if(Eg)return xg;Eg=1;const e=requireFlatten$1(),r=requireAreAllShapesTheSameType(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),i=function requireHullPath2(){if(mg)return dg;mg=1;const e=requireFlatten$1(),r=requirePath2(),t=requireHullPoints2(),n=requireToUniquePoints();return dg=(...o)=>{o=e(o);const i=n(o),s=t(i);return r.fromPoints({closed:!0},s)},dg}(),s=function requireHullGeom2(){if(pg)return qg;pg=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireHullPoints2(),n=requireToUniquePoints();return qg=(...o)=>{o=e(o);const i=n(o),s=t(i);return s.length<3?r.create():r.fromPoints(s)},qg}(),u=function requireHullGeom3(){if(bg)return wg;bg=1;const e=requireFlatten$1(),r=requireGeom3(),t=requireToUniquePoints(),n=requireHullPoints3();return wg=(...o)=>{o=e(o);const i=t(o);return 0===i.length?r.create():r.create(n(i))},wg}();return xg=(...a)=>{if(0===(a=e(a)).length)throw new Error("wrong number of arguments");if(!r(a))throw new Error("only hulls of the same type are supported");const c=a[0];return o.isA(c)?i(a):t.isA(c)?s(a):n.isA(c)?u(a):c},xg}function requireHullChain(){if($g)return Ag;$g=1;const e=requireFlatten$1(),r=requireUnion(),t=requireHull();return Ag=(...n)=>{if((n=e(n)).length<2)throw new Error("wrong number of arguments");const o=[];for(let e=1;e<n.length;e++)o.push(t(n[e-1],n[e]));return r(o)},Ag}function requireSnapPolygons(){if(Cg)return Tg;Cg=1;const e=requireVec3(),r=requirePoly3();return Tg=(t,n)=>{let o=n.map(n=>{const o=n.vertices.map(r=>e.snap(e.create(),r,t)),i=[];for(let r=0;r<o.length;r++){const t=(r+1)%o.length;e.equals(o[r],o[t])||i.push(o[r])}const s=r.create(i);return n.color&&(s.color=n.color),s});const i=t*t*Math.sqrt(3)/4;return o=o.filter(e=>((e,t)=>{const n=Math.abs(r.measureArea(t));return Number.isFinite(n)&&n>e})(i,e)),o}}function requireMergePolygons(){if(Fg)return Sg;Fg=1;const e=requireAboutEqualNormals(),r=requireVec3(),t=requirePoly3(),createEdges=e=>{const r=t.toPoints(e),n=[];for(let e=0;e<r.length;e++){const t=(e+1)%r.length,o={v1:r[e],v2:r[t]};n.push(o)}for(let e=0;e<n.length;e++){const t=(e+1)%r.length;n[e].next=n[t],n[t].prev=n[e]}return n},insertEdge=(e,r)=>{const t=`${r.v1}:${r.v2}`;e.set(t,r)},deleteEdge=(e,r)=>{const t=`${r.v1}:${r.v2}`;e.delete(t)},findOppositeEdge=(e,r)=>{const t=`${r.v2}:${r.v1}`;return e.get(t)},calculateAnglesBetween=(e,r,t)=>{let n=e.prev.v1,o=e.prev.v2,i=r.next.v2;const s=calculateAngle(n,o,i,t);n=r.prev.v1,o=r.prev.v2,i=e.next.v2;return[s,calculateAngle(n,o,i,t)]},n=r.create(),o=r.create(),calculateAngle=(e,t,i,s)=>{const u=r.subtract(n,t,e),a=r.subtract(o,i,t);return r.cross(u,u,a),r.dot(u,s)},mergeCoplanarPolygons=e=>{if(e.length<2)return e;const r=e[0].plane,n=e.slice(),o=new Map;for(;n.length>0;){const e=n.shift(),t=createEdges(e);for(let e=0;e<t.length;e++){const n=t[e],i=findOppositeEdge(o,n);if(i){const e=calculateAnglesBetween(n,i,r);if(e[0]>=0&&e[1]>=0){const r=i.next,t=n.next;n.prev.next=i.next,n.next.prev=i.prev,i.prev.next=n.next,i.next.prev=n.prev,n.v1=null,n.v2=null,n.next=null,n.prev=null,deleteEdge(o,i),i.v1=null,i.v2=null,i.next=null,i.prev=null;const mergeEdges=(e,r,t)=>{const n={v1:t.v1,v2:r.v2,next:r.next,prev:t.prev};t.prev.next=n,r.next.prev=n,deleteEdge(e,r),r.v1=null,r.v2=null,r.next=null,r.prev=null,deleteEdge(e,t),t.v1=null,t.v2=null,t.next=null,t.prev=null};0===e[0]&&mergeEdges(o,r,r.prev),0===e[1]&&mergeEdges(o,t,t.prev)}}else n.next&&insertEdge(o,n)}}const i=[];return o.forEach(e=>{const r=(e=>{let r;const n=[];for(;e.next;){const r=e.next;n.push(e.v1),e.v1=null,e.v2=null,e.next=null,e.prev=null,e=r}return n.length>0&&(r=t.create(n)),r})(e);r&&i.push(r)}),o.clear(),i};return Sg=(r,n)=>{const o=[];n.forEach(r=>{const n=o.find(n=>{return o=n[0],i=t.plane(r),Math.abs(o[3]-i[3])<15e-8&&e(o,i);var o,i});if(n){n[1].push(r)}else o.push([t.plane(r),[r]])});let i=[];return o.forEach(e=>{const r=e[1],t=mergeCoplanarPolygons(r);i=i.concat(t)}),i}}function requireTriangulatePolygons(){if(kg)return Gg;kg=1;const e=requireVec3(),r=requirePoly3();return Gg=(t,n)=>{const o=[];return n.forEach(n=>{((t,n,o)=>{const i=n.vertices.length;if(i>3){if(i>4){const s=[0,0,0];n.vertices.forEach(r=>e.add(s,s,r)),e.snap(s,e.divide(s,s,[i,i,i]),t);for(let e=0;e<i;e++){const t=r.create([s,n.vertices[e],n.vertices[(e+1)%i]]);n.color&&(t.color=n.color),o.push(t)}return}const s=r.create([n.vertices[0],n.vertices[1],n.vertices[2]]),u=r.create([n.vertices[0],n.vertices[2],n.vertices[3]]);return n.color&&(s.color=n.color,u.color=n.color),void o.push(s,u)}o.push(n)})(t,n,o)}),o}}function requireGeneralize(){if(Og)return Ng;Og=1;const e=requireFlatten$1(),r=requireMeasureEpsilon(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),i=requireSnapPolygons(),s=requireMergePolygons(),u=function requireInsertTjunctions(){if(Rg)return Vg;Rg=1;const e=requireConstants(),r=requireVec3(),t=requirePoly3(),getTag=e=>`${e}`,addSide=(e,r,t,n,o,i)=>{const s=getTag(n),u=getTag(o),a=`${s}/${u}`,c=`${u}/${s}`;if(e.has(c))return deleteSide(e,r,t,o,n,null),null;const l={vertex0:n,vertex1:o,polygonindex:i};return e.has(a)?e.get(a).push(l):e.set(a,[l]),r.has(s)?r.get(s).push(a):r.set(s,[a]),t.has(u)?t.get(u).push(a):t.set(u,[a]),a},deleteSide=(e,r,t,n,o,i)=>{const s=getTag(n),u=getTag(o),a=`${s}/${u}`;let c=-1;const l=e.get(a);for(let e=0;e<l.length;e++){const r=l[e];let t=getTag(r.vertex0);if(t===s&&(t=getTag(r.vertex1),t===u&&(null===i||r.polygonindex===i))){c=e;break}}l.splice(c,1),0===l.length&&e.delete(a),c=r.get(s).indexOf(a),r.get(s).splice(c,1),0===r.get(s).length&&r.delete(s),c=t.get(u).indexOf(a),t.get(u).splice(c,1),0===t.get(u).length&&t.delete(u)};return Vg=n=>{const o=new Map;for(let e=0;e<n.length;e++){const r=n[e],t=r.vertices.length;if(t>=3){let n=r.vertices[0],i=getTag(n);for(let s=0;s<t;s++){let u=s+1;u===t&&(u=0);const a=r.vertices[u],c=getTag(a),l=`${i}/${c}`,f=`${c}/${i}`;if(o.has(f)){const e=o.get(f);e.splice(-1,1),0===e.length&&o.delete(f)}else{const r={vertex0:n,vertex1:a,polygonindex:e};o.has(l)?o.get(l).push(r):o.set(l,[r])}n=a,i=c}}else console.warn("warning: invalid polygon found during insertTjunctions")}if(o.size>0){const i=new Map,s=new Map,u=new Map;for(const[e,r]of o)u.set(e,!0),r.forEach(r=>{const t=getTag(r.vertex0),n=getTag(r.vertex1);i.has(t)?i.get(t).push(e):i.set(t,[e]),s.has(n)?s.get(n).push(e):s.set(n,[e])});const a=n.slice(0);for(;0!==o.size;){for(const e of o.keys())u.set(e,!0);let n=!1;for(;;){const c=Array.from(u.keys());if(0===c.length)break;const l=c[0];let f=!0;if(o.has(l)){const c=o.get(l)[0];for(let l=0;l<2;l++){const h=0===l?c.vertex0:c.vertex1,g=0===l?c.vertex1:c.vertex0,d=getTag(h),m=getTag(g);let q=[];0===l?s.has(d)&&(q=s.get(d)):i.has(d)&&(q=i.get(d));for(let c=0;c<q.length;c++){const d=q[c],p=o.get(d)[0],y=0===l?p.vertex0:p.vertex1;if(0===l?p.vertex1:p.vertex0,getTag(y)===m){deleteSide(o,i,s,h,g,null),deleteSide(o,i,s,g,h,null),f=!1,l=2,n=!0;break}{const c=h,d=g,m=y,q=r.subtract(r.create(),m,c),v=r.dot(r.subtract(r.create(),d,c),q)/r.dot(q,q);if(v>0&&v<1){const h=r.scale(r.create(),q,v);if(r.add(h,h,c),r.squaredDistance(h,d)<e.EPS*e.EPS){const e=p.polygonindex,r=a[e],c=getTag(p.vertex1);let h=-1;for(let e=0;e<r.vertices.length;e++)if(getTag(r.vertices[e])===c){h=e;break}const d=r.vertices.slice(0);d.splice(h,0,g);const m=t.create(d);a[e]=m,deleteSide(o,i,s,p.vertex0,p.vertex1,e);const q=addSide(o,i,s,p.vertex0,g,e),y=addSide(o,i,s,g,p.vertex1,e);null!==q&&u.set(q,!0),null!==y&&u.set(y,!0),f=!1,l=2,n=!0;break}}}}}}f&&u.delete(l)}if(!n)break}n=a}return o.clear(),n}}(),a=requireTriangulatePolygons();return Ng=(c,...l)=>{if(0===(l=e(l)).length)throw new Error("wrong number of arguments");const f=l.map(e=>{if(o.isA(e))return((e,r)=>r)(0,e);if(t.isA(e))return((e,r)=>r)(0,e);if(n.isA(e))return((e,t)=>{const{snap:o,simplify:c,triangulate:l}=Object.assign({},{snap:!1,simplify:!1,triangulate:!1},e),f=r(t);let h=n.toPolygons(t);o&&(h=i(f,h)),c&&(h=s(f,h)),l&&(h=u(h),h=a(f,h));const g=Object.assign({},t);return g.polygons=h,g})(c,e);throw new Error("invalid geometry")});return 1===f.length?f[0]:f},Ng}function requireSnap(){if(Ig)return zg;Ig=1;const e=requireFlatten$1(),r=requireVec2(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),i=requireMeasureEpsilon(),s=requireSnapPolygons();return zg=(...u)=>{if(0===(u=e(u)).length)throw new Error("wrong number of arguments");const a=u.map(e=>o.isA(e)?(e=>{const t=i(e),n=o.toPoints(e).map(e=>r.snap(r.create(),e,t));return o.create(n)})(e):t.isA(e)?(e=>{const n=i(e);let o=t.toSides(e).map(e=>[r.snap(r.create(),e[0],n),r.snap(r.create(),e[1],n)]);return o=o.filter(e=>!r.equals(e[0],e[1])),t.create(o)})(e):n.isA(e)?(e=>{const r=i(e),t=n.toPolygons(e),o=s(r,t);return n.create(o)})(e):e);return 1===a.length?a[0]:a},zg}function requireAlign(){if(Zg)return _g;Zg=1;const e=requireFlatten$1(),r=function requirePadArrayToLength(){return Lg?jg:(Lg=1,jg=(e,r,t)=>{for(e=e.slice();e.length<t;)e.push(r);return e})}(),t=requireMeasureAggregateBoundingBox(),{translate:n}=requireTranslate(),alignGeometries=(e,r,o)=>{const i=t(e),s=[0,0,0];for(let e=0;e<3;e++)"center"===r[e]?s[e]=o[e]-(i[0][e]+i[1][e])/2:"max"===r[e]?s[e]=o[e]-i[1][e]:"min"===r[e]&&(s[e]=o[e]-i[0][e]);return n(s,e)};return _g=(n,...o)=>{n=(e=>{if(!Array.isArray(e.modes)||e.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(e.modes=r(e.modes,"none",3),3!==e.modes.filter(e=>["center","max","min","none"].includes(e)).length)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(e.relativeTo)||e.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(e.relativeTo=r(e.relativeTo,0,3),3!==e.relativeTo.filter(e=>Number.isFinite(e)||null==e).length)throw new Error("align(): all relativeTo values must be a number, or null.");if("boolean"!=typeof e.grouped)throw new Error("align(): grouped must be a boolean value.");return e})(n=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},n));let{modes:i,relativeTo:s,grouped:u}=n;if(0===(o=e(o)).length)throw new Error("align(): No geometries were provided to act upon");if(s.filter(e=>null==e).length){const e=t(o);s=((e,r,t)=>{for(let n=0;n<3;n++)null==e[n]&&("center"===r[n]?e[n]=(t[0][n]+t[1][n])/2:"max"===r[n]?e[n]=t[1][n]:"min"===r[n]&&(e[n]=t[0][n]));return e})(s,i,e)}return 1===(o=u?alignGeometries(o,i,s):o.map(e=>alignGeometries(e,i,s))).length?o[0]:o},_g}function requireCenter(){if(Ug)return Xg;Ug=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2(),o=requireMeasureBoundingBox(),{translate:i}=requireTranslate(),centerGeometry=(e,r)=>{const{axes:t,relativeTo:n}=Object.assign({},{axes:[!0,!0,!0],relativeTo:[0,0,0]},e),s=o(r),u=[0,0,0];return t[0]&&(u[0]=n[0]-(s[0][0]+(s[1][0]-s[0][0])/2)),t[1]&&(u[1]=n[1]-(s[0][1]+(s[1][1]-s[0][1])/2)),t[2]&&(u[2]=n[2]-(s[0][2]+(s[1][2]-s[0][2])/2)),i(u,r)},center=(o,...i)=>{const{axes:s,relativeTo:u}=Object.assign({},{axes:[!0,!0,!0],relativeTo:[0,0,0]},o);if(0===(i=e(i)).length)throw new Error("wrong number of arguments");if(3!==u.length)throw new Error("relativeTo must be an array of length 3");o={axes:s,relativeTo:u};const a=i.map(e=>n.isA(e)||r.isA(e)||t.isA(e)?centerGeometry(o,e):e);return 1===a.length?a[0]:a};return Xg={center:center,centerX:(...e)=>center({axes:[!0,!1,!1]},e),centerY:(...e)=>center({axes:[!1,!0,!1]},e),centerZ:(...e)=>center({axes:[!1,!1,!0]},e)}}function requireScale(){if(Yg)return Hg;Yg=1;const e=requireFlatten$1(),r=requireMat4(),t=requireGeom2(),n=requireGeom3(),o=requirePath2(),scale=(i,...s)=>{if(!Array.isArray(i))throw new Error("factors must be an array");if(0===(s=e(s)).length)throw new Error("wrong number of arguments");for(i=i.slice();i.length<3;)i.push(1);if(i[0]<=0||i[1]<=0||i[2]<=0)throw new Error("factors must be positive");const u=r.fromScaling(r.create(),i),a=s.map(e=>o.isA(e)?o.transform(u,e):t.isA(e)?t.transform(u,e):n.isA(e)?n.transform(u,e):e);return 1===a.length?a[0]:a};return Hg={scale:scale,scaleX:(e,...r)=>scale([e,1,1],r),scaleY:(e,...r)=>scale([1,e,1],r),scaleZ:(e,...r)=>scale([1,1,e],r)}}function requireTransform(){if(Jg)return Wg;Jg=1;const e=requireFlatten$1(),r=requireGeom2(),t=requireGeom3(),n=requirePath2();return Wg=(o,...i)=>{if(0===(i=e(i)).length)throw new Error("wrong number of arguments");const s=i.map(e=>n.isA(e)?n.transform(o,e):r.isA(e)?r.transform(o,e):t.isA(e)?t.transform(o,e):e);return 1===s.length?s[0]:s}}function requireSrc$1(){return rd?ed:(rd=1,ed={colors:Vs?Fs:(Vs=1,Fs={colorize:requireColorize(),colorNameToRgb:requireColorNameToRgb(),cssColors:requireCssColors(),hexToRgb:requireHexToRgb(),hslToRgb:requireHslToRgb(),hsvToRgb:requireHsvToRgb(),hueToColorComponent:requireHueToColorComponent(),rgbToHex:requireRgbToHex(),rgbToHsl:requireRgbToHsl(),rgbToHsv:requireRgbToHsv()}),curves:Hs?Us:(Hs=1,Us={bezier:Xs?Zs:(Xs=1,Zs={create:requireCreate$4(),valueAt:requireValueAt(),tangentAt:requireTangentAt(),lengths:requireLengths(),length:requireLength(),arcLengthToT:requireArcLengthToT()})}),geometries:requireGeometries(),maths:Sa?Ca:(Sa=1,Ca={constants:requireConstants(),line2:requireLine2(),line3:Ta?Ma:(Ta=1,Ma={clone:requireClone$1(),closestPoint:requireClosestPoint(),copy:requireCopy(),create:requireCreate$1(),direction:requireDirection(),distanceToPoint:requireDistanceToPoint(),equals:requireEquals$1(),fromPlanes:requireFromPlanes(),fromPointAndDirection:requireFromPointAndDirection(),fromPoints:requireFromPoints$1(),intersectPointOfLineAndPlane:requireIntersectPointOfLineAndPlane(),origin:requireOrigin(),reverse:requireReverse$1(),toString:requireToString$1(),transform:requireTransform$2()}),mat4:requireMat4(),plane:requirePlane$1(),utils:requireUtils$1(),vec2:requireVec2(),vec3:requireVec3(),vec4:requireVec4()}),measurements:oc?nc:(oc=1,nc={measureAggregateArea:requireMeasureAggregateArea(),measureAggregateBoundingBox:requireMeasureAggregateBoundingBox(),measureAggregateEpsilon:requireMeasureAggregateEpsilon(),measureAggregateVolume:requireMeasureAggregateVolume(),measureArea:requireMeasureArea(),measureBoundingBox:requireMeasureBoundingBox(),measureBoundingSphere:requireMeasureBoundingSphere(),measureCenter:requireMeasureCenter(),measureCenterOfMass:requireMeasureCenterOfMass(),measureDimensions:requireMeasureDimensions(),measureEpsilon:requireMeasureEpsilon(),measureVolume:requireMeasureVolume()}),primitives:Ql?Jl:(Ql=1,Jl={arc:requireArc(),circle:requireCircle(),cube:requireCube(),cuboid:requireCuboid(),cylinder:requireCylinder(),cylinderElliptic:requireCylinderElliptic(),ellipse:requireEllipse(),ellipsoid:requireEllipsoid(),geodesicSphere:requireGeodesicSphere(),line:requireLine(),polygon:requirePolygon(),polyhedron:requirePolyhedron(),rectangle:requireRectangle(),roundedCuboid:requireRoundedCuboid(),roundedCylinder:requireRoundedCylinder(),roundedRectangle:requireRoundedRectangle(),sphere:requireSphere(),square:requireSquare(),star:requireStar(),torus:requireTorus(),triangle:requireTriangle()}),text:cf?af:(cf=1,af={vectorChar:requireVectorChar(),vectorText:requireVectorText()}),utils:requireUtils(),booleans:Eh?xh:(Eh=1,xh={intersect:requireIntersect(),scission:requireScission(),subtract:requireSubtract(),union:requireUnion()}),expansions:Zh?_h:(Zh=1,_h={expand:requireExpand(),offset:requireOffset()}),extrusions:cg?ag:(cg=1,ag={extrudeFromSlices:requireExtrudeFromSlices(),extrudeLinear:requireExtrudeLinear(),extrudeRectangular:requireExtrudeRectangular(),extrudeRotate:requireExtrudeRotate(),extrudeHelical:requireExtrudeHelical(),project:requireProject(),slice:requireSlice()}),hulls:Mg?Pg:(Mg=1,Pg={hull:requireHull(),hullChain:requireHullChain(),hullPoints2:requireHullPoints2(),hullPoints3:requireHullPoints3()}),modifiers:Dg?Bg:(Dg=1,Bg={generalize:requireGeneralize(),snap:requireSnap(),retessellate:requireRetessellate()}),transforms:Kg?Qg:(Kg=1,Qg={align:requireAlign(),center:requireCenter().center,centerX:requireCenter().centerX,centerY:requireCenter().centerY,centerZ:requireCenter().centerZ,mirror:requireMirror().mirror,mirrorX:requireMirror().mirrorX,mirrorY:requireMirror().mirrorY,mirrorZ:requireMirror().mirrorZ,rotate:requireRotate().rotate,rotateX:requireRotate().rotateX,rotateY:requireRotate().rotateY,rotateZ:requireRotate().rotateZ,scale:requireScale().scale,scaleX:requireScale().scaleX,scaleY:requireScale().scaleY,scaleZ:requireScale().scaleZ,transform:requireTransform(),translate:requireTranslate().translate,translateX:requireTranslate().translateX,translateY:requireTranslate().translateY,translateZ:requireTranslate().translateZ})})}var td,nd,od=requireSrc$1();function requireStringify(){if(nd)return td;nd=1;return td=function stringify(e,r){const t=r>0?"\n":"",n=function indenter(e){if(!(e>0))return e=>e;var r=" ".repeat(e);return e=>{if("string"!=typeof e)return e;const t=e.split("\n");return 1===t.length?r+e:t.map(e=>""===e.trim()?e:r+e).join("\n")}}(r);return function rec(e){let r,o="",i=!0;return e.some((e,n,s)=>{if(0===n)return r="<"+e,1===s.length;if(1===n){if((u=e)&&"[object Object]"===Object.prototype.toString.call(u))return Object.keys(e).map(t=>{let n=e[t];Array.isArray(n)&&(n=n.join(" ")),r+=" "+t+'="'+n+'"'}),2===s.length||void(r+=">");r+=">"}var u;switch(typeof e){case"string":case"number":case"boolean":case"undefined":return void(o+=e+t)}i=!1,o+=rec(e)})?r+"/>"+t:i?r+o.split("\n").filter(e=>""!==e.trim()).join("\n")+"</"+e[0]+">"+t:r+t+n(o)+"</"+e[0]+">"+t}(e)}}var id,sd,ud="2.3.19";var ad,cd,ld,fd,hd,gd,dd,md,qd,pd,yd,vd,wd,bd,xd,Ed,Ad,$d,Pd=function requireSvgSerializer(){if(sd)return id;sd=1;const{geometries:e,maths:r,measurements:t,utils:n}=requireSrc$1(),o=requireStringify(),i=ud,getBounds=e=>{const n=t.measureBoundingBox(e);if(1===e.length)return n;return n.reduce((e,t)=>(r.vec3.min(e[0],e[0],t[0]),r.vec3.max(e[1],e[1],t[1]),e),[[0,0,0],[0,0,0]])},convertObjects=(r,t,n)=>{const o=0-t[0][0],i=0-t[1][1],s=[];return r.forEach((t,u)=>{n.statusCallback&&n.statusCallback({progress:100*u/r.length}),e.geom2.isA(t)&&s.push(convertGeom2(t,[o,i],n)),e.path2.isA(t)&&s.push(convertPaths([t],[o,i],n))}),s},reflect=(e,r,t,n)=>{const o=e-t,i=r-n;return e===t&&r===t?[e,r]:e===t?[e,n-i]:r===n?[t- -o,r]:[t- -o,n-i]},convertGeom2=(r,t,n)=>{const o=e.geom2.toOutlines(r).map(r=>e.path2.fromPoints({closed:!0},r));return n.color="black",r.color&&(n.color=convertColor(r.color)),n.id=null,r.id&&(n.id=r.id),n.class=null,r.class&&(n.class=r.class),convertToContinousPath(o,t,n)},convertToContinousPath=(e,r,t)=>{let n="";e.forEach(e=>n+=convertPath(e,r,t));const o={fill:t.color,d:n};return t.id&&(o.id=t.id),t.class&&(o.class=t.class),["g",["path",o]]},convertPaths=(e,r,t)=>e.reduce((e,n,o)=>{const i={d:convertPath(n,r,t)};return n.color&&(i.stroke=convertColor(n.color)),n.id&&(i.id=n.id),n.class&&(i.class=n.class),e.concat([["path",i]])},["g"]),convertPath=(e,r,t)=>{let n="";const o=e.points.length+(e.isClosed?1:0);for(let i=0;i<o;i++){let o=i;o>=e.points.length&&(o-=e.points.length);const s=e.points[o],u=[s[0]+r[0],s[1]+r[1]],a=reflect(u[0],u[1],0,0),c=Math.round(a[0]*t.decimals)/t.decimals,l=Math.round(a[1]*t.decimals)/t.decimals;n+=i>0?`L${c} ${l}`:`M${c} ${l}`}return n},convertColor=e=>`rgba(${255*e[0]},${255*e[1]},${255*e[2]},${e[3]})`;return id={serialize:(r,...t)=>{const s={unit:"mm",decimals:1e4,version:i,statusCallback:null};r=Object.assign({},s,r);const u=(t=n.flatten(t)).filter(r=>e.geom2.isA(r)||e.path2.isA(r));if(0===u.length)throw new Error("only 2D geometries can be serialized to SVG");t.length!==u.length&&console.warn("some objects could not be serialized to SVG"),r.statusCallback&&r.statusCallback({progress:0});const a=getBounds(u);let c=0,l=0;a&&(c=Math.round((a[1][0]-a[0][0])*r.decimals)/r.decimals,l=Math.round((a[1][1]-a[0][1])*r.decimals)/r.decimals);let f=["svg",{width:c+r.unit,height:l+r.unit,viewBox:"0 0 "+c+" "+l,fill:"none","fill-rule":"evenodd","stroke-width":"0.1px",version:"1.1",baseProfile:"tiny",xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink"}];a&&(f=f.concat(convertObjects(u,a,r)));const h=`<?xml version="1.0" encoding="UTF-8"?>\n\x3c!-- Created by JSCAD SVG Serializer --\x3e\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">\n${o(f,2)}`;return r.statusCallback&&r.statusCallback({progress:100}),[h]},mimeType:"image/svg+xml"}}();function requireFlatten(){if(cd)return ad;cd=1;const flatten=e=>e.reduce((e,r)=>Array.isArray(r)?e.concat(flatten(r)):e.concat(r),[]);return ad=flatten}function requireFnNumberSort(){if(fd)return ld;fd=1;return ld=(e,r)=>e-r}function requireHead(){if(gd)return hd;gd=1;return hd=e=>{if(Array.isArray(e)&&0!==e.length)return e[0]}}function requireInsertSorted(){if(md)return dd;md=1;return dd=(e,r,t)=>{let n=0,o=e.length;for(;o>n;){const i=Math.floor((n+o)/2);t(r,e[i])>0?n=i+1:o=i}return e.splice(n,0,r),e}}function requireNth(){if(pd)return qd;pd=1;return qd=(e,r)=>{if(Array.isArray(e)&&!(e.length<r))return e[r]}}function requirePadToLength(){if(vd)return yd;vd=1;return yd=(e,r,t)=>{for(e=e.slice();e.length<t;)e.push(r);return e}}function requireToArray(){if(bd)return wd;bd=1;return wd=e=>Array.isArray(e)?e:null==e?[]:[e]}var Md,Td,Cd=function requireObjSerializer(){if($d)return Ad;$d=1;const{colors:e,geometries:r,modifiers:t}=requireSrc$1(),{flatten:n,toArray:o}=function requireSrc(){return Ed?xd:(Ed=1,xd={flatten:requireFlatten(),fnNumberSort:requireFnNumberSort(),head:requireHead(),insertSorted:requireInsertSorted(),nth:requireNth(),padToLength:requirePadToLength(),toArray:requireToArray()})}(),convertVertex=e=>`v ${e[0]} ${e[1]} ${e[2]}`,getColorName=r=>{let t;if(r.color){const n=r.color[0],o=r.color[1],i=r.color[2];let s=765;for(const r in e.cssColors){const u=e.cssColors[r],a=Math.abs(n-u[0])+Math.abs(o-u[1])+Math.abs(i-u[2]);if(a<s){if(t=r,0===a)break;s=a}}}return t};return Ad={serialize:(e,...i)=>{e=Object.assign({},{statusCallback:null,triangulate:!0},e);let s=(i=n(i)).filter(e=>r.geom3.isA(e));if(0===s.length)throw new Error("only 3D geometries can be serialized to OBJ");i.length!==s.length&&console.warn("some objects could not be serialized to OBJ"),s=o(t.generalize({snap:!0,triangulate:e.triangulate},s)),e.statusCallback&&e.statusCallback({progress:0});let u="# Wavefront OBJ file generated by JSCAD\n";const a=[];let c="default";return s.forEach((t,n)=>{e.statusCallback&&e.statusCallback({progress:100*n/s.length}),u+="\n";const o=getColorName(t),i=r.geom3.toPolygons(t).filter(e=>e.vertices.length>=3);i.forEach(e=>{e.vertices.forEach(e=>{const r=convertVertex(e);a.indexOf(r)<0&&(a.push(r),u+=`${r}\n`)})}),u+="\n",i.forEach(e=>{const r=e.vertices.map(e=>a.indexOf(convertVertex(e))+1),t=getColorName(e)||o||"default";t!==c&&(u+=`usemtl ${t}\n`,c=t),u+=`f ${r.join(" ")}\n`})}),e.statusCallback&&e.statusCallback({progress:100}),[u]},mimeType:"application/object"}}();var Sd=function requireJsonSerializer(){if(Td)return Md;Td=1;const{utils:e}=requireSrc$1(),replacer=(e,r)=>{switch(e){case"transforms":case"plane":return Array.from(r);case"points":case"vertices":return r.map(e=>Array.from(e));case"sides":return r.map(e=>[Array.from(e[0]),Array.from(e[1])])}return r};return Md={serialize:(r,...t)=>{r=Object.assign({},{statusCallback:null},r),t=e.flatten(t),r.statusCallback&&r.statusCallback({progress:0});const n=JSON.stringify(t,replacer);return r.statusCallback&&r.statusCallback({progress:100}),[n]},mimeType:"application/json"}}();const Fd=[0,0],Vd=[0,0,0],Rd=[0,1],Gd=[0,1,0],kd=[0,0,0],Nd=32,Od=od.colors.hexToRgb("#938fb8");function arr3To2(e){return[e[0],e[1]]}function arr2To3(e,r=null){return[e[0],e[1],r]}function toRadians(e){return e*(Math.PI/180)}class Path2Ctx{constructor(e){this._path=e,0==e.points.length&&(this._path=od.geometries.path2.appendPoints([Fd],this._path))}linear(e){return this._path=od.geometries.path2.appendPoints(e,this._path),this}bezier(e,r=32){return this._path=od.geometries.path2.appendBezier({controlPoints:[null,...e],segments:r},this._path),this}arc(e,r,t=!1,n=!1,o=32){return this._path=od.geometries.path2.appendArc({endpoint:e,radius:r,clockwise:t,large:n,segments:o},this._path),this}build(e=!1,r=!0,t,n="edge"){let o;return e&&!this._path.isClosed&&(this._path=od.geometries.path2.close(this._path)),o=r?od.expansions.expand({delta:t,corners:n},this._path):od.geometries.geom2.fromPoints(od.geometries.path2.toPoints(this._path)),new Geo2Ctx(o)}}class Geo2Ctx{constructor(e){this._geo=e}scale(e){return new Geo2Ctx(od.transforms.scale(e,this._geo))}spin(e){return new Geo2Ctx(od.transforms.rotate([toRadians(e)],this._geo))}move(e){return new Geo2Ctx(od.transforms.translate(e,this._geo))}center(e,r=[!0,!0]){return new Geo2Ctx(od.transforms.center({relativeTo:arr2To3(e,0),axes:arr2To3(r,!1)},this._geo))}align(e,r){return new Geo2Ctx(od.transforms.align({modes:arr2To3(r,"none"),relativeTo:arr2To3(e,null),grouped:!0},this._geo))}mirror(e=Fd,r=Rd){return new Geo2Ctx(od.transforms.mirror({origin:arr2To3(e,0),normal:arr2To3(r,0)},this._geo))}add(e){return new Geo2Ctx(od.booleans.union(this._geo,e._geo))}sub(e){return new Geo2Ctx(od.booleans.subtract(this._geo,e._geo))}inter(e){return new Geo2Ctx(od.booleans.intersect(this._geo,e._geo))}hull(...e){return new Geo2Ctx(od.hulls.hull(this._geo,e.map(e=>e._geo)))}chain(...e){return new Geo2Ctx(od.hulls.hullChain(this._geo,e.map(e=>e._geo)))}extrude(e,r=0,t=360){return new Geo3Ctx(od.extrusions.extrudeLinear({height:e,twistAngle:toRadians(t),twistSteps:r},this._geo))}box(){let e=od.measurements.measureBoundingBox(this._geo);return[arr3To2(e[0]),arr3To2(e[1])]}size(){return arr3To2(od.measurements.measureDimensions(this._geo))}write(e="svg",r=Od){let t=od.colors.colorize(r,this._geo);return"svg"===e?Pd.serialize({unit:"mm"},t):Sd.serialize({},t)}}class Geo3Ctx{constructor(e){this._geo=e}scale(e){return new Geo3Ctx(od.transforms.scale(e,this._geo))}spin(e){return new Geo3Ctx(od.transforms.rotate([toRadians(e[0]),toRadians(e[1]),toRadians(e[2])],this._geo))}move(e){return new Geo3Ctx(od.transforms.translate(e,this._geo))}center(e,r=[!0,!0,!0]){return new Geo3Ctx(od.transforms.center({relativeTo:e,axes:r},this._geo))}align(e,r){return new Geo3Ctx(od.transforms.align({modes:r,relativeTo:e,grouped:!0},this._geo))}mirror(e=Vd,r=Gd){return new Geo3Ctx(od.transforms.mirror({origin:e,normal:r},this._geo))}add(e){return new Geo3Ctx(od.booleans.union(this._geo,e._geo))}sub(e){return new Geo3Ctx(od.booleans.subtract(this._geo,e._geo))}inter(e){return new Geo3Ctx(od.booleans.intersect(this._geo,e._geo))}hull(...e){return new Geo3Ctx(od.hulls.hull(this._geo,e.map(e=>e._geo)))}chain(...e){return new Geo3Ctx(od.hulls.hullChain(this._geo,e.map(e=>e._geo)))}project(e,r=kd){return new Geo2Ctx(od.extrusions.project({origin:e,axis:r},this._geo))}box(){return od.measurements.measureBoundingBox(this._geo)}size(){return od.measurements.measureDimensions(this._geo)}write(e="obj",r=Od){let t=od.colors.colorize(r,this._geo);return"obj"===e?Cd.serialize({triangulate:!1},t):Sd.serialize({},t)}}e.GEO_COLOR=Od,e.GEO_EXTENT=2,e.GEO_FORMAT2="svg",e.GEO_FORMAT3="obj",e.GEO_QUARTER=.5,e.GEO_RADIUS=1,e.GEO_SEGMENTS=Nd,e.GEO_UNIT="mm",e.Geo2Ctx=Geo2Ctx,e.Geo3Ctx=Geo3Ctx,e.NORM2_X=[1,0],e.NORM2_Y=Rd,e.NORM3_X=[1,0,0],e.NORM3_Y=Gd,e.NORM3_Z=kd,e.Path2Ctx=Path2Ctx,e.ZERO2=Fd,e.ZERO3=Vd,e.arr1To3=function arr1To3(e,r=null){return[e[0],r,r]},e.arr2To3=arr2To3,e.arr3To1=function arr3To1(e){return[e[0]]},e.arr3To2=arr3To2,e.arr3ToV=function arr3ToV(e){return e[0]},e.arrVTo3=function arrVTo3(e,r=null){return[e,r,r]},e.cuboid=function cuboid(e=Vd,r=[2,2,2],t,n){let o;return o=void 0===t?od.primitives.roundedCuboid({center:e,size:r,roundRadius:t??1,segments:n??Nd}):od.primitives.cuboid({center:e,size:r}),new Geo3Ctx(o)},e.cylinder=function cylinder(e=Vd,r=1,t=2,n=32){let o;return o=r instanceof Number?od.primitives.cylinder({center:e,height:t,radius:r,segments:n}):od.primitives.cylinderElliptic({center:e,height:t,startRadius:r[0],endRadius:r[1],startAngle:0,endAngle:2*Math.PI,segments:n}),new Geo3Ctx(o)},e.ellipsoid=function ellipsoid(e=Vd,r=[1,1,1],t=32){let n=od.primitives.ellipsoid({center:e,radius:r,segments:t});return new Geo3Ctx(n)},e.isArr=function isArr(e){return Array.isArray(e)},e.isArr1=function isArr1(e){return Array.isArray(e)&&1==e.length},e.isArr2=function isArr2(e){return Array.isArray(e)&&2==e.length},e.isArr3=function isArr3(e){return Array.isArray(e)&&3==e.length},e.isArr4=function isArr4(e){return Array.isArray(e)&&4==e.length},e.isGeo2=function isGeo2(e){return od.geometries.geom2.isA(e)},e.isGeo3=function isGeo3(e){return od.geometries.geom3.isA(e)},e.isInt=function isInt(e){return Number.isInteger(e)},e.isNum=function isNum(e){return Number.isFinite(e)},e.isStr=function isStr(e){return e instanceof String},e.shape=function shape(e){return new Path2Ctx(od.geometries.path2.create(void 0!==e?[e]:[Fd]))},e.toDegrees=function toDegrees(e){return e*(180/Math.PI)},e.toRadians=toRadians,e.torus=function torus(e=Vd,r=[.5,1],t=32){let n=od.primitives.torus({innerRadius:r[0],outerRadius:r[1],innerSegments:t,outerSegments:t});return 0==e[0]&&0==e[1]&&0==e[2]||(n=od.transforms.translate(e,n)),new Geo3Ctx(n)}});
